<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://mobxjs.github.io/mobx">mobx (v3.1.9)</a>
</h1>
<h4>Simple, scalable state management.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx">module mobx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Atom">
            function <span class="apidocSignatureSpan">mobx.</span>Atom
            <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.BaseAtom">
            function <span class="apidocSignatureSpan">mobx.</span>BaseAtom
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories">
            function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.deep">
            function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories.prototype.deep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.ref">
            function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories.prototype.ref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap">
            function <span class="apidocSignatureSpan">mobx.</span>ObservableMap
            <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction">
            function <span class="apidocSignatureSpan">mobx.</span>Reaction
            <span class="apidocSignatureSpan">(name, onInvalidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.action">
            function <span class="apidocSignatureSpan">mobx.</span>action
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.asFlat">
            function <span class="apidocSignatureSpan">mobx.</span>asFlat
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.asMap">
            function <span class="apidocSignatureSpan">mobx.</span>asMap
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.asReference">
            function <span class="apidocSignatureSpan">mobx.</span>asReference
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.asStructure">
            function <span class="apidocSignatureSpan">mobx.</span>asStructure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.autorun">
            function <span class="apidocSignatureSpan">mobx.</span>autorun
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.autorunAsync">
            function <span class="apidocSignatureSpan">mobx.</span>autorunAsync
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.computed">
            function <span class="apidocSignatureSpan">mobx.</span>computed
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.createTransformer">
            function <span class="apidocSignatureSpan">mobx.</span>createTransformer
            <span class="apidocSignatureSpan">(transformer, onCleanup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.expr">
            function <span class="apidocSignatureSpan">mobx.</span>expr
            <span class="apidocSignatureSpan">(expr, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extendObservable">
            function <span class="apidocSignatureSpan">mobx.</span>extendObservable
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extendShallowObservable">
            function <span class="apidocSignatureSpan">mobx.</span>extendShallowObservable
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.intercept">
            function <span class="apidocSignatureSpan">mobx.</span>intercept
            <span class="apidocSignatureSpan">(thing, propOrHandler, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isAction">
            function <span class="apidocSignatureSpan">mobx.</span>isAction
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isArrayLike">
            function <span class="apidocSignatureSpan">mobx.</span>isArrayLike
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isBoxedObservable">
            function <span class="apidocSignatureSpan">mobx.</span>isBoxedObservable
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isComputed">
            function <span class="apidocSignatureSpan">mobx.</span>isComputed
            <span class="apidocSignatureSpan">(value, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isModifierDescriptor">
            function <span class="apidocSignatureSpan">mobx.</span>isModifierDescriptor
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isObservable">
            function <span class="apidocSignatureSpan">mobx.</span>isObservable
            <span class="apidocSignatureSpan">(value, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isObservableArray">
            function <span class="apidocSignatureSpan">mobx.</span>isObservableArray
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isObservableMap">
            function <span class="apidocSignatureSpan">mobx.</span>isObservableMap
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isObservableObject">
            function <span class="apidocSignatureSpan">mobx.</span>isObservableObject
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.isStrictModeEnabled">
            function <span class="apidocSignatureSpan">mobx.</span>isStrictModeEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.map">
            function <span class="apidocSignatureSpan">mobx.</span>map
            <span class="apidocSignatureSpan">(initialValues)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable">
            function <span class="apidocSignatureSpan">mobx.</span>observable
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observe">
            function <span class="apidocSignatureSpan">mobx.</span>observe
            <span class="apidocSignatureSpan">(thing, propOrCb, cbOrFire, fireImmediately)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.reaction">
            function <span class="apidocSignatureSpan">mobx.</span>reaction
            <span class="apidocSignatureSpan">(expression, effect, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.runInAction">
            function <span class="apidocSignatureSpan">mobx.</span>runInAction
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.spy">
            function <span class="apidocSignatureSpan">mobx.</span>spy
            <span class="apidocSignatureSpan">(listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.toJS">
            function <span class="apidocSignatureSpan">mobx.</span>toJS
            <span class="apidocSignatureSpan">(source, detectCycles, __alreadySeen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.transaction">
            function <span class="apidocSignatureSpan">mobx.</span>transaction
            <span class="apidocSignatureSpan">(action, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.untracked">
            function <span class="apidocSignatureSpan">mobx.</span>untracked
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.useStrict">
            function <span class="apidocSignatureSpan">mobx.</span>useStrict
            <span class="apidocSignatureSpan">(strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.when">
            function <span class="apidocSignatureSpan">mobx.</span>when
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.whyRun">
            function <span class="apidocSignatureSpan">mobx.</span>whyRun
            <span class="apidocSignatureSpan">(thing, prop)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>Atom.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>BaseAtom.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>IDerivationState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>IObservableFactories.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>ObservableMap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>Reaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>extras</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>mobx_umd</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.Atom">module mobx.Atom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Atom.Atom">
            function <span class="apidocSignatureSpan">mobx.</span>Atom
            <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.Atom.prototype">module mobx.Atom.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Atom.prototype.constructor">
            function <span class="apidocSignatureSpan">mobx.Atom.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Atom.prototype.onBecomeUnobserved">
            function <span class="apidocSignatureSpan">mobx.Atom.prototype.</span>onBecomeUnobserved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Atom.prototype.reportObserved">
            function <span class="apidocSignatureSpan">mobx.Atom.prototype.</span>reportObserved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.BaseAtom">module mobx.BaseAtom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.BaseAtom.BaseAtom">
            function <span class="apidocSignatureSpan">mobx.</span>BaseAtom
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.BaseAtom.prototype">module mobx.BaseAtom.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>isMobXAtom</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.BaseAtom.prototype.onBecomeUnobserved">
            function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>onBecomeUnobserved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.BaseAtom.prototype.reportChanged">
            function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>reportChanged
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.BaseAtom.prototype.reportObserved">
            function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>reportObserved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.BaseAtom.prototype.toString">
            function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.IObservableFactories">module mobx.IObservableFactories</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.IObservableFactories">
            function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.IObservableFactories.prototype">module mobx.IObservableFactories.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.array">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>array
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.box">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>box
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.deep">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>deep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.map">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>map
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.object">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>object
            <span class="apidocSignatureSpan">(props, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.ref">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>ref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.shallow">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.shallowArray">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowArray
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.shallowBox">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowBox
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.shallowMap">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowMap
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.shallowObject">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowObject
            <span class="apidocSignatureSpan">(props, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.struct">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>struct
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.IObservableFactories.prototype.deep">module mobx.IObservableFactories.prototype.deep</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.deep.deep">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>deep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.deep.struct">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.deep.</span>struct
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.IObservableFactories.prototype.ref">module mobx.IObservableFactories.prototype.ref</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.ref.ref">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>ref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.IObservableFactories.prototype.ref.struct">
            function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.ref.</span>struct
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.ObservableMap">module mobx.ObservableMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.ObservableMap">
            function <span class="apidocSignatureSpan">mobx.</span>ObservableMap
            <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.ObservableMap.prototype">module mobx.ObservableMap.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>isMobXObservableMap</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype._addValue">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_addValue
            <span class="apidocSignatureSpan">(name, newValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype._has">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_has
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype._updateHasMapEntry">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_updateHasMapEntry
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype._updateValue">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_updateValue
            <span class="apidocSignatureSpan">(name, newValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.assertValidKey">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>assertValidKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.clear">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.delete">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>delete
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.entries">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>entries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.forEach">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.get">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.has">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>has
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.intercept">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>intercept
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.isValidKey">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>isValidKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.keys">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.merge">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>merge
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.observe">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>observe
            <span class="apidocSignatureSpan">(listener, fireImmediately)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.replace">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>replace
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.set">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>set
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.toJS">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>toJS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.toJSON">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.toString">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.ObservableMap.prototype.values">
            function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.Reaction">module mobx.Reaction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.Reaction">
            function <span class="apidocSignatureSpan">mobx.</span>Reaction
            <span class="apidocSignatureSpan">(name, onInvalidate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.Reaction.prototype">module mobx.Reaction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>isMobXReaction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.dispose">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.getDisposer">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>getDisposer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.isScheduled">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>isScheduled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.onBecomeStale">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>onBecomeStale
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.reportExceptionInDerivation">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>reportExceptionInDerivation
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.runReaction">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>runReaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.schedule">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>schedule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.toString">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.track">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>track
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.Reaction.prototype.whyRun">
            function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>whyRun
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.action">module mobx.action</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.action.action">
            function <span class="apidocSignatureSpan">mobx.</span>action
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.action.bound">
            function <span class="apidocSignatureSpan">mobx.action.</span>bound
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.computed">module mobx.computed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.computed.computed">
            function <span class="apidocSignatureSpan">mobx.</span>computed
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.computed.struct">
            function <span class="apidocSignatureSpan">mobx.computed.</span>struct
            <span class="apidocSignatureSpan">(target, key, descriptor, customArgs, argLen)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.default">module mobx.default</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.Atom">
            function <span class="apidocSignatureSpan">mobx.default.</span>Atom
            <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.BaseAtom">
            function <span class="apidocSignatureSpan">mobx.default.</span>BaseAtom
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.IObservableFactories">
            function <span class="apidocSignatureSpan">mobx.default.</span>IObservableFactories
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.ObservableMap">
            function <span class="apidocSignatureSpan">mobx.default.</span>ObservableMap
            <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.Reaction">
            function <span class="apidocSignatureSpan">mobx.default.</span>Reaction
            <span class="apidocSignatureSpan">(name, onInvalidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.action">
            function <span class="apidocSignatureSpan">mobx.default.</span>action
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.asFlat">
            function <span class="apidocSignatureSpan">mobx.default.</span>asFlat
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.asMap">
            function <span class="apidocSignatureSpan">mobx.default.</span>asMap
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.asReference">
            function <span class="apidocSignatureSpan">mobx.default.</span>asReference
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.asStructure">
            function <span class="apidocSignatureSpan">mobx.default.</span>asStructure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.autorun">
            function <span class="apidocSignatureSpan">mobx.default.</span>autorun
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.autorunAsync">
            function <span class="apidocSignatureSpan">mobx.default.</span>autorunAsync
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.computed">
            function <span class="apidocSignatureSpan">mobx.default.</span>computed
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.createTransformer">
            function <span class="apidocSignatureSpan">mobx.default.</span>createTransformer
            <span class="apidocSignatureSpan">(transformer, onCleanup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.expr">
            function <span class="apidocSignatureSpan">mobx.default.</span>expr
            <span class="apidocSignatureSpan">(expr, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.extendObservable">
            function <span class="apidocSignatureSpan">mobx.default.</span>extendObservable
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.extendShallowObservable">
            function <span class="apidocSignatureSpan">mobx.default.</span>extendShallowObservable
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.intercept">
            function <span class="apidocSignatureSpan">mobx.default.</span>intercept
            <span class="apidocSignatureSpan">(thing, propOrHandler, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isAction">
            function <span class="apidocSignatureSpan">mobx.default.</span>isAction
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isArrayLike">
            function <span class="apidocSignatureSpan">mobx.default.</span>isArrayLike
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isBoxedObservable">
            function <span class="apidocSignatureSpan">mobx.default.</span>isBoxedObservable
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isComputed">
            function <span class="apidocSignatureSpan">mobx.default.</span>isComputed
            <span class="apidocSignatureSpan">(value, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isModifierDescriptor">
            function <span class="apidocSignatureSpan">mobx.default.</span>isModifierDescriptor
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isObservable">
            function <span class="apidocSignatureSpan">mobx.default.</span>isObservable
            <span class="apidocSignatureSpan">(value, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isObservableArray">
            function <span class="apidocSignatureSpan">mobx.default.</span>isObservableArray
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isObservableMap">
            function <span class="apidocSignatureSpan">mobx.default.</span>isObservableMap
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isObservableObject">
            function <span class="apidocSignatureSpan">mobx.default.</span>isObservableObject
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.isStrictModeEnabled">
            function <span class="apidocSignatureSpan">mobx.default.</span>isStrictModeEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.map">
            function <span class="apidocSignatureSpan">mobx.default.</span>map
            <span class="apidocSignatureSpan">(initialValues)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.observable">
            function <span class="apidocSignatureSpan">mobx.default.</span>observable
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.observe">
            function <span class="apidocSignatureSpan">mobx.default.</span>observe
            <span class="apidocSignatureSpan">(thing, propOrCb, cbOrFire, fireImmediately)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.reaction">
            function <span class="apidocSignatureSpan">mobx.default.</span>reaction
            <span class="apidocSignatureSpan">(expression, effect, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.runInAction">
            function <span class="apidocSignatureSpan">mobx.default.</span>runInAction
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.spy">
            function <span class="apidocSignatureSpan">mobx.default.</span>spy
            <span class="apidocSignatureSpan">(listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.toJS">
            function <span class="apidocSignatureSpan">mobx.default.</span>toJS
            <span class="apidocSignatureSpan">(source, detectCycles, __alreadySeen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.transaction">
            function <span class="apidocSignatureSpan">mobx.default.</span>transaction
            <span class="apidocSignatureSpan">(action, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.untracked">
            function <span class="apidocSignatureSpan">mobx.default.</span>untracked
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.useStrict">
            function <span class="apidocSignatureSpan">mobx.default.</span>useStrict
            <span class="apidocSignatureSpan">(strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.when">
            function <span class="apidocSignatureSpan">mobx.default.</span>when
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.default.whyRun">
            function <span class="apidocSignatureSpan">mobx.default.</span>whyRun
            <span class="apidocSignatureSpan">(thing, prop)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.default.</span>IDerivationState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.default.</span>extras</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.extras">module mobx.extras</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.allowStateChanges">
            function <span class="apidocSignatureSpan">mobx.extras.</span>allowStateChanges
            <span class="apidocSignatureSpan">(allowStateChanges, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.deepEqual">
            function <span class="apidocSignatureSpan">mobx.extras.</span>deepEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.getAdministration">
            function <span class="apidocSignatureSpan">mobx.extras.</span>getAdministration
            <span class="apidocSignatureSpan">(thing, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.getAtom">
            function <span class="apidocSignatureSpan">mobx.extras.</span>getAtom
            <span class="apidocSignatureSpan">(thing, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.getDebugName">
            function <span class="apidocSignatureSpan">mobx.extras.</span>getDebugName
            <span class="apidocSignatureSpan">(thing, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.getDependencyTree">
            function <span class="apidocSignatureSpan">mobx.extras.</span>getDependencyTree
            <span class="apidocSignatureSpan">(thing, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.getGlobalState">
            function <span class="apidocSignatureSpan">mobx.extras.</span>getGlobalState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.getObserverTree">
            function <span class="apidocSignatureSpan">mobx.extras.</span>getObserverTree
            <span class="apidocSignatureSpan">(thing, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.isComputingDerivation">
            function <span class="apidocSignatureSpan">mobx.extras.</span>isComputingDerivation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.isSpyEnabled">
            function <span class="apidocSignatureSpan">mobx.extras.</span>isSpyEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.onReactionError">
            function <span class="apidocSignatureSpan">mobx.extras.</span>onReactionError
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.reserveArrayBuffer">
            function <span class="apidocSignatureSpan">mobx.extras.</span>reserveArrayBuffer
            <span class="apidocSignatureSpan">(max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.resetGlobalState">
            function <span class="apidocSignatureSpan">mobx.extras.</span>resetGlobalState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.setReactionScheduler">
            function <span class="apidocSignatureSpan">mobx.extras.</span>setReactionScheduler
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.shareGlobalState">
            function <span class="apidocSignatureSpan">mobx.extras.</span>shareGlobalState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.spyReport">
            function <span class="apidocSignatureSpan">mobx.extras.</span>spyReport
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.spyReportEnd">
            function <span class="apidocSignatureSpan">mobx.extras.</span>spyReportEnd
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.extras.spyReportStart">
            function <span class="apidocSignatureSpan">mobx.extras.</span>spyReportStart
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.mobx_umd">module mobx.mobx_umd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.Atom">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>Atom
            <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.BaseAtom">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>BaseAtom
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.IObservableFactories">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>IObservableFactories
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.ObservableMap">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>ObservableMap
            <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.Reaction">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>Reaction
            <span class="apidocSignatureSpan">(name, onInvalidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.action">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>action
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.asFlat">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asFlat
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.asMap">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asMap
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.asReference">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asReference
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.asStructure">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asStructure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.autorun">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>autorun
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.autorunAsync">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>autorunAsync
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.computed">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>computed
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.createTransformer">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>createTransformer
            <span class="apidocSignatureSpan">(transformer, onCleanup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.expr">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>expr
            <span class="apidocSignatureSpan">(expr, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.extendObservable">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>extendObservable
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.extendShallowObservable">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>extendShallowObservable
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.intercept">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>intercept
            <span class="apidocSignatureSpan">(thing, propOrHandler, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isAction">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isAction
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isArrayLike">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isArrayLike
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isBoxedObservable">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isBoxedObservable
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isComputed">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isComputed
            <span class="apidocSignatureSpan">(value, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isModifierDescriptor">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isModifierDescriptor
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isObservable">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservable
            <span class="apidocSignatureSpan">(value, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isObservableArray">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservableArray
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isObservableMap">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservableMap
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isObservableObject">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservableObject
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.isStrictModeEnabled">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isStrictModeEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.map">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>map
            <span class="apidocSignatureSpan">(initialValues)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.observable">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>observable
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.observe">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>observe
            <span class="apidocSignatureSpan">(thing, propOrCb, cbOrFire, fireImmediately)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.reaction">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>reaction
            <span class="apidocSignatureSpan">(expression, effect, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.runInAction">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>runInAction
            <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.spy">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>spy
            <span class="apidocSignatureSpan">(listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.toJS">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>toJS
            <span class="apidocSignatureSpan">(source, detectCycles, __alreadySeen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.transaction">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>transaction
            <span class="apidocSignatureSpan">(action, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.untracked">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>untracked
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.useStrict">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>useStrict
            <span class="apidocSignatureSpan">(strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.when">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>when
            <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.mobx_umd.whyRun">
            function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>whyRun
            <span class="apidocSignatureSpan">(thing, prop)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.mobx_umd.</span>IDerivationState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.mobx_umd.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mobx.mobx_umd.</span>extras</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mobx.observable">module mobx.observable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.observable">
            function <span class="apidocSignatureSpan">mobx.</span>observable
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.array">
            function <span class="apidocSignatureSpan">mobx.observable.</span>array
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.box">
            function <span class="apidocSignatureSpan">mobx.observable.</span>box
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.deep">
            function <span class="apidocSignatureSpan">mobx.observable.</span>deep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.map">
            function <span class="apidocSignatureSpan">mobx.observable.</span>map
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.object">
            function <span class="apidocSignatureSpan">mobx.observable.</span>object
            <span class="apidocSignatureSpan">(props, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.ref">
            function <span class="apidocSignatureSpan">mobx.observable.</span>ref
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.shallow">
            function <span class="apidocSignatureSpan">mobx.observable.</span>shallow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.shallowArray">
            function <span class="apidocSignatureSpan">mobx.observable.</span>shallowArray
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.shallowBox">
            function <span class="apidocSignatureSpan">mobx.observable.</span>shallowBox
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.shallowMap">
            function <span class="apidocSignatureSpan">mobx.observable.</span>shallowMap
            <span class="apidocSignatureSpan">(initialValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.shallowObject">
            function <span class="apidocSignatureSpan">mobx.observable.</span>shallowObject
            <span class="apidocSignatureSpan">(props, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mobx.observable.struct">
            function <span class="apidocSignatureSpan">mobx.observable.</span>struct
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx" id="apidoc.module.mobx">module mobx</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.Atom" id="apidoc.element.mobx.Atom">
        function <span class="apidocSignatureSpan">mobx.</span>Atom
        <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
    if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
    var _this = _super.call(this, name) || this;
    _this.name = name;
    _this.onBecomeObservedHandler = onBecomeObservedHandler;
    _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;
    _this.isPendingUnobservation = false;
    _this.isBeingTracked = false;
    return _this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.BaseAtom" id="apidoc.element.mobx.BaseAtom">
        function <span class="apidocSignatureSpan">mobx.</span>BaseAtom
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseAtom(name) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    this.name = name;
    this.isPendingUnobservation = true;
    this.observers = [];
    this.observersIndexes = {};
    this.diffValue = 0;
    this.lastAccessedBy = 0;
    this.lowestObserverState = IDerivationState.NOT_TRACKING;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories" id="apidoc.element.mobx.IObservableFactories">
        function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IObservableFactories() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.deep" id="apidoc.element.mobx.IObservableFactories.prototype.deep">
        function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories.prototype.deep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IObservableFactories.prototype.deep = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(deepEnhancer, arguments[0]);
    }
    else {
        return deepDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.ref" id="apidoc.element.mobx.IObservableFactories.prototype.ref">
        function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories.prototype.ref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">IObservableFactories.prototype.ref = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(referenceEnhancer, arguments[0]);
    }
    else {
        return refDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap" id="apidoc.element.mobx.ObservableMap">
        function <span class="apidocSignatureSpan">mobx.</span>ObservableMap
        <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableMap(initialData, enhancer, name) {
    if (enhancer === void 0) { enhancer = deepEnhancer; }
    if (name === void 0) { name = "ObservableMap@" + getNextId(); }
    this.enhancer = enhancer;
    this.name = name;
    this.$mobx = ObservableMapMarker;
    this._data = Object.create(null);
    this._hasMap = Object.create(null);
    this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true);
    this.interceptors = null;
    this.changeListeners = null;
    this.merge(initialData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction" id="apidoc.element.mobx.Reaction">
        function <span class="apidocSignatureSpan">mobx.</span>Reaction
        <span class="apidocSignatureSpan">(name, onInvalidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reaction(name, onInvalidate) {
    if (name === void 0) { name = "Reaction@" + getNextId(); }
    this.name = name;
    this.onInvalidate = onInvalidate;
    this.observing = [];
    this.newObserving = [];
    this.dependenciesState = IDerivationState.NOT_TRACKING;
    this.diffValue = 0;
    this.runId = 0;
    this.unboundDepsCount = 0;
    this.__mapid = "#" + getNextId();
    this.isDisposed = false;
    this._isScheduled = false;
    this._isTrackPending = false;
    this._isRunning = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.action" id="apidoc.element.mobx.action">
        function <span class="apidocSignatureSpan">mobx.</span>action
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function action(arg1, arg2, arg3, arg4) {
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "function")
        return createAction(arg1.name || "&lt;unnamed action&gt;", arg1);
    if (arguments.length === 2 &amp;&amp; typeof arg2 === "function")
        return createAction(arg1, arg2);
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "string")
        return namedActionDecorator(arg1);
    return namedActionDecorator(arg2).apply(null, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.asFlat" id="apidoc.element.mobx.asFlat">
        function <span class="apidocSignatureSpan">mobx.</span>asFlat
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.asMap" id="apidoc.element.mobx.asMap">
        function <span class="apidocSignatureSpan">mobx.</span>asMap
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asMap(data) {
    deprecated("asMap is deprecated, use observable.map or observable.shallowMap instead");
    return observable.map(data || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.asReference" id="apidoc.element.mobx.asReference">
        function <span class="apidocSignatureSpan">mobx.</span>asReference
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.asStructure" id="apidoc.element.mobx.asStructure">
        function <span class="apidocSignatureSpan">mobx.</span>asStructure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.struct(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.autorun" id="apidoc.element.mobx.autorun">
        function <span class="apidocSignatureSpan">mobx.</span>autorun
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autorun(arg1, arg2, arg3) {
    var name, view, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        view = arg2;
        scope = arg3;
    }
    else {
        name = arg1.name || ("Autorun@" + getNextId());
        view = arg1;
        scope = arg2;
    }
    invariant(typeof view === "function", getMessage("m004"));
    invariant(isAction(view) === false, getMessage("m005"));
    if (scope)
        view = view.bind(scope);
    var reaction = new Reaction(name, function () {
        this.track(reactionRunner);
    });
    function reactionRunner() {
        view(reaction);
    }
    reaction.schedule();
    return reaction.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.autorunAsync" id="apidoc.element.mobx.autorunAsync">
        function <span class="apidocSignatureSpan">mobx.</span>autorunAsync
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autorunAsync(arg1, arg2, arg3, arg4) {
    var name, func, delay, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        func = arg2;
        delay = arg3;
        scope = arg4;
    }
    else {
        name = arg1.name || ("AutorunAsync@" + getNextId());
        func = arg1;
        delay = arg2;
        scope = arg3;
    }
    invariant(isAction(func) === false, getMessage("m006"));
    if (delay === void 0)
        delay = 1;
    if (scope)
        func = func.bind(scope);
    var isScheduled = false;
    var r = new Reaction(name, function () {
        if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                if (!r.isDisposed)
                    r.track(reactionRunner);
            }, delay);
        }
    });
    function reactionRunner() { func(r); }
    r.schedule();
    return r.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `toJSON` now serializes object trees with cycles as well. If you know the object tree is acyclic, pass in `false` as second parameter
 for a performance gain.

# 1.1.0

* Exposed `ObservableMap` type
* Introduced `mobservable.untracked(block)`
* Introduced `mobservable.<span class="apidocCodeKeywordSpan">autorunAsync</span>(block, delay)`

# 1.0.9

Removed accidental log message

# 1.0.7 / 1.0.8
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.computed" id="apidoc.element.mobx.computed">
        function <span class="apidocSignatureSpan">mobx.</span>computed
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        return computedDecorator.apply(null, arguments);
    }
    invariant(typeof arg1 === "function", getMessage("m011"));
    invariant(arguments.length &lt; 3, getMessage("m012"));
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.setter = typeof arg2 === "function" ? arg2 : opts.setter;
    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || "", opts
.setter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.createTransformer" id="apidoc.element.mobx.createTransformer">
        function <span class="apidocSignatureSpan">mobx.</span>createTransformer
        <span class="apidocSignatureSpan">(transformer, onCleanup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTransformer(transformer, onCleanup) {
    invariant(typeof transformer === "function" &amp;&amp; transformer.length &lt; 2, "createTransformer expects a function that accepts one
 argument");
    var objectCache = {};
    var resetId = globalState.resetId;
    var Transformer = (function (_super) {
        __extends(Transformer, _super);
        function Transformer(sourceIdentifier, sourceObject) {
            var _this = _super.call(this, function () { return transformer(sourceObject); }, undefined, false, "Transformer-" +
transformer.name + "-" + sourceIdentifier, undefined) || this;
            _this.sourceIdentifier = sourceIdentifier;
            _this.sourceObject = sourceObject;
            return _this;
        }
        Transformer.prototype.onBecomeUnobserved = function () {
            var lastValue = this.value;
            _super.prototype.onBecomeUnobserved.call(this);
            delete objectCache[this.sourceIdentifier];
            if (onCleanup)
                onCleanup(lastValue, this.sourceObject);
        };
        return Transformer;
    }(ComputedValue));
    return function (object) {
        if (resetId !== globalState.resetId) {
            objectCache = {};
            resetId = globalState.resetId;
        }
        var identifier = getMemoizationId(object);
        var reactiveTransformer = objectCache[identifier];
        if (reactiveTransformer)
            return reactiveTransformer.get();
        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);
        return reactiveTransformer.get();
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.expr" id="apidoc.element.mobx.expr">
        function <span class="apidocSignatureSpan">mobx.</span>expr
        <span class="apidocSignatureSpan">(expr, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expr(expr, scope) {
    if (!isComputingDerivation())
        console.warn(getMessage("m013"));
    return computed(expr, { context: scope }).get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extendObservable" id="apidoc.element.mobx.extendObservable">
        function <span class="apidocSignatureSpan">mobx.</span>extendObservable
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendObservable(target) {
    var properties = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, deepEnhancer, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extendShallowObservable" id="apidoc.element.mobx.extendShallowObservable">
        function <span class="apidocSignatureSpan">mobx.</span>extendShallowObservable
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendShallowObservable(target) {
    var properties = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, referenceEnhancer, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.intercept" id="apidoc.element.mobx.intercept">
        function <span class="apidocSignatureSpan">mobx.</span>intercept
        <span class="apidocSignatureSpan">(thing, propOrHandler, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intercept(thing, propOrHandler, handler) {
    if (typeof handler === "function")
        return interceptProperty(thing, propOrHandler, handler);
    else
        return interceptInterceptable(thing, propOrHandler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof handler === "function")
    return interceptProperty(thing, propOrHandler, handler);
else
    return interceptInterceptable(thing, propOrHandler);
}
exports.intercept = intercept;
function interceptInterceptable(thing, handler) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">intercept</span>(handler);
}
function interceptProperty(thing, property, handler) {
return getAdministration(thing, property).intercept(handler);
}
function isComputed(value, property) {
if (value === null || value === undefined)
    return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isAction" id="apidoc.element.mobx.isAction">
        function <span class="apidocSignatureSpan">mobx.</span>isAction
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAction(thing) {
    return typeof thing === "function" &amp;&amp; thing.isMobxAction === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isArrayLike" id="apidoc.element.mobx.isArrayLike">
        function <span class="apidocSignatureSpan">mobx.</span>isArrayLike
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayLike(x) {
    return Array.isArray(x) || isObservableArray(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isBoxedObservable" id="apidoc.element.mobx.isBoxedObservable">
        function <span class="apidocSignatureSpan">mobx.</span>isBoxedObservable
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBoxedObservable = function (x) {
    return isObject(x) &amp;&amp; x[propName] === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isComputed" id="apidoc.element.mobx.isComputed">
        function <span class="apidocSignatureSpan">mobx.</span>isComputed
        <span class="apidocSignatureSpan">(value, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isComputed(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableObject(value) === false)
            return false;
        var atom = getAtom(value, property);
        return isComputedValue(atom);
    }
    return isComputedValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isModifierDescriptor" id="apidoc.element.mobx.isModifierDescriptor">
        function <span class="apidocSignatureSpan">mobx.</span>isModifierDescriptor
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModifierDescriptor(thing) {
    return typeof thing === "object" &amp;&amp; thing !== null &amp;&amp; thing.isMobxModifierDescriptor === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isObservable" id="apidoc.element.mobx.isObservable">
        function <span class="apidocSignatureSpan">mobx.</span>isObservable
        <span class="apidocSignatureSpan">(value, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservable(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableArray(value) || isObservableMap(value))
            throw new Error(getMessage("m019"));
        else if (isObservableObject(value)) {
            var o = value.$mobx;
            return o.values &amp;&amp; !!o.values[property];
        }
        return false;
    }
    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isObservableArray" id="apidoc.element.mobx.isObservableArray">
        function <span class="apidocSignatureSpan">mobx.</span>isObservableArray
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservableArray(thing) {
    return isObject(thing) &amp;&amp; isObservableArrayAdministration(thing.$mobx);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isObservableMap" id="apidoc.element.mobx.isObservableMap">
        function <span class="apidocSignatureSpan">mobx.</span>isObservableMap
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObservableMap = function (x) {
    return isObject(x) &amp;&amp; x[propName] === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isObservableObject" id="apidoc.element.mobx.isObservableObject">
        function <span class="apidocSignatureSpan">mobx.</span>isObservableObject
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservableObject(thing) {
    if (isObject(thing)) {
        runLazyInitializers(thing);
        return isObservableObjectAdministration(thing.$mobx);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.isStrictModeEnabled" id="apidoc.element.mobx.isStrictModeEnabled">
        function <span class="apidocSignatureSpan">mobx.</span>isStrictModeEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStrictModeEnabled() {
    return globalState.strictMode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.map" id="apidoc.element.mobx.map">
        function <span class="apidocSignatureSpan">mobx.</span>map
        <span class="apidocSignatureSpan">(initialValues)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(initialValues) {
    deprecated("`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead");
    return observable.map(initialValues);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.<span class="apidocCodeKeywordSpan">map</span>(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable" id="apidoc.element.mobx.observable">
        function <span class="apidocSignatureSpan">mobx.</span>observable
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createObservable(v) {
    if (v === void 0) { v = undefined; }
    if (typeof arguments[1] === "string")
        return deepDecorator.apply(null, arguments);
    invariant(arguments.length &lt;= 1, getMessage("m021"));
    invariant(!isModifierDescriptor(v), getMessage("m020"));
    if (isObservable(v))
        return v;
    var res = deepEnhancer(v, undefined, undefined);
    if (res !== v)
        return res;
    return observable.box(v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# 1.1.7

* Fixed #77: package consumers with --noImplicitAny should be able to build

# 1.1.6

* Introduced `mobservable.fastArray(array)`, in addition to `mobservable.<span class="apidocCodeKeywordSpan">observable</span>(array
)`. Which is much faster when adding items but doesn't support enumerability (`for (var idx in ar) ..` loops).
* Introduced `observableArray.peek()`, for fast access to the array values. Should be used read-only.

# 1.1.5

* Fixed 71: transactions should not influence running computations

# 1.1.4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observe" id="apidoc.element.mobx.observe">
        function <span class="apidocSignatureSpan">mobx.</span>observe
        <span class="apidocSignatureSpan">(thing, propOrCb, cbOrFire, fireImmediately)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function observe(thing, propOrCb, cbOrFire, fireImmediately) {
    if (typeof cbOrFire === "function")
        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    else
        return observeObservable(thing, propOrCb, cbOrFire);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof cbOrFire === "function")
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
else
    return observeObservable(thing, propOrCb, cbOrFire);
}
exports.observe = observe;
function observeObservable(thing, listener, fireImmediately) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">observe</span>(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
return getAdministration(thing, property).observe(listener, fireImmediately);
}
function toJS(source, detectCycles, __alreadySeen) {
if (detectCycles === void 0) { detectCycles = true; }
if (__alreadySeen === void 0) { __alreadySeen = []; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.reaction" id="apidoc.element.mobx.reaction">
        function <span class="apidocSignatureSpan">mobx.</span>reaction
        <span class="apidocSignatureSpan">(expression, effect, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reaction(expression, effect, arg3) {
    if (arguments.length &gt; 3) {
        fail(getMessage("m007"));
    }
    if (isModifierDescriptor(expression)) {
        fail(getMessage("m008"));
    }
    var opts;
    if (typeof arg3 === "object") {
        opts = arg3;
    }
    else {
        opts = {};
    }
    opts.name = opts.name || expression.name || effect.name || ("Reaction@" + getNextId());
    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;
    opts.delay = opts.delay || 0;
    opts.compareStructural = opts.compareStructural || opts.struct || false;
    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);
    if (opts.context) {
        expression = expression.bind(opts.context);
    }
    var firstTime = true;
    var isScheduled = false;
    var nextValue;
    var r = new Reaction(opts.name, function () {
        if (firstTime || opts.delay &lt; 1) {
            reactionRunner();
        }
        else if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                reactionRunner();
            }, opts.delay);
        }
    });
    function reactionRunner() {
        if (r.isDisposed)
            return;
        var changed = false;
        r.track(function () {
            var v = expression(r);
            changed = valueDidChange(opts.compareStructural, nextValue, v);
            nextValue = v;
        });
        if (firstTime &amp;&amp; opts.fireImmediately)
            effect(nextValue, r);
        if (!firstTime &amp;&amp; changed === true)
            effect(nextValue, r);
        if (firstTime)
            firstTime = false;
    }
    r.schedule();
    return r.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.runInAction" id="apidoc.element.mobx.runInAction">
        function <span class="apidocSignatureSpan">mobx.</span>runInAction
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runInAction(arg1, arg2, arg3) {
    var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "&lt;unnamed action&gt;";
    var fn = typeof arg1 === "function" ? arg1 : arg2;
    var scope = typeof arg1 === "function" ? arg2 : arg3;
    invariant(typeof fn === "function", getMessage("m002"));
    invariant(fn.length === 0, getMessage("m003"));
    invariant(typeof actionName === "string" &amp;&amp; actionName.length &gt; 0, "actions should have valid names, got: '" + actionName + "'");
    return executeAction(actionName, fn, scope, undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.spy" id="apidoc.element.mobx.spy">
        function <span class="apidocSignatureSpan">mobx.</span>spy
        <span class="apidocSignatureSpan">(listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spy(listener) {
    globalState.spyListeners.push(listener);
    return once(function () {
        var idx = globalState.spyListeners.indexOf(listener);
        if (idx !== -1)
            globalState.spyListeners.splice(idx, 1);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.toJS" id="apidoc.element.mobx.toJS">
        function <span class="apidocSignatureSpan">mobx.</span>toJS
        <span class="apidocSignatureSpan">(source, detectCycles, __alreadySeen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJS(source, detectCycles, __alreadySeen) {
    if (detectCycles === void 0) { detectCycles = true; }
    if (__alreadySeen === void 0) { __alreadySeen = []; }
    function cache(value) {
        if (detectCycles)
            __alreadySeen.push([source, value]);
        return value;
    }
    if (isObservable(source)) {
        if (detectCycles &amp;&amp; __alreadySeen === null)
            __alreadySeen = [];
        if (detectCycles &amp;&amp; source !== null &amp;&amp; typeof source === "object") {
            for (var i = 0, l = __alreadySeen.length; i &lt; l; i++)
                if (__alreadySeen[i][0] === source)
                    return __alreadySeen[i][1];
        }
        if (isObservableArray(source)) {
            var res = cache([]);
            var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); });
            res.length = toAdd.length;
            for (var i = 0, l = toAdd.length; i &lt; l; i++)
                res[i] = toAdd[i];
            return res;
        }
        if (isObservableObject(source)) {
            var res = cache({});
            for (var key in source)
                res[key] = toJS(source[key], detectCycles, __alreadySeen);
            return res;
        }
        if (isObservableMap(source)) {
            var res_1 = cache({});
            source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); });
            return res_1;
        }
        if (isObservableValue(source))
            return toJS(source.get(), detectCycles, __alreadySeen);
    }
    return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ObservableArray.prototype.replace = function (newItems) {
    return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
};
ObservableArray.prototype.toJS = function () {
    return this.slice();
};
ObservableArray.prototype.toJSON = function () {
    return this.<span class="apidocCodeKeywordSpan">toJS</span>();
};
ObservableArray.prototype.peek = function () {
    return this.$mobx.values;
};
ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
    if (fromIndex === void 0) { fromIndex = 0; }
    this.$mobx.atom.reportObserved();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.transaction" id="apidoc.element.mobx.transaction">
        function <span class="apidocSignatureSpan">mobx.</span>transaction
        <span class="apidocSignatureSpan">(action, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transaction(action, thisArg) {
    if (thisArg === void 0) { thisArg = undefined; }
    deprecated(getMessage("m023"));
    return runInTransaction.apply(undefined, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.untracked" id="apidoc.element.mobx.untracked">
        function <span class="apidocSignatureSpan">mobx.</span>untracked
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function untracked(action) {
    var prev = untrackedStart();
    var res = action();
    untrackedEnd(prev);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
# 1.1.1

* `toJSON` now serializes object trees with cycles as well. If you know the object tree is acyclic, pass in `false` as second parameter
 for a performance gain.

# 1.1.0

* Exposed `ObservableMap` type
* Introduced `mobservable.<span class="apidocCodeKeywordSpan">untracked</span>(block)`
* Introduced `mobservable.autorunAsync(block, delay)`

# 1.0.9

Removed accidental log message

# 1.0.7 / 1.0.8
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.useStrict" id="apidoc.element.mobx.useStrict">
        function <span class="apidocSignatureSpan">mobx.</span>useStrict
        <span class="apidocSignatureSpan">(strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function useStrict(strict) {
    invariant(globalState.trackingDerivation === null, getMessage("m028"));
    globalState.strictMode = strict;
    globalState.allowStateChanges = !strict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.when" id="apidoc.element.mobx.when">
        function <span class="apidocSignatureSpan">mobx.</span>when
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function when(arg1, arg2, arg3, arg4) {
    var name, predicate, effect, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        predicate = arg2;
        effect = arg3;
        scope = arg4;
    }
    else {
        name = ("When@" + getNextId());
        predicate = arg1;
        effect = arg2;
        scope = arg3;
    }
    var disposer = autorun(name, function (r) {
        if (predicate.call(scope)) {
            r.dispose();
            var prevUntracked = untrackedStart();
            effect.call(scope);
            untrackedEnd(prevUntracked);
        }
    });
    return disposer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.whyRun" id="apidoc.element.mobx.whyRun">
        function <span class="apidocSignatureSpan">mobx.</span>whyRun
        <span class="apidocSignatureSpan">(thing, prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whyRun(thing, prop) {
    switch (arguments.length) {
        case 0:
            thing = globalState.trackingDerivation;
            if (!thing)
                return log(getMessage("m024"));
            break;
        case 2:
            thing = getAtom(thing, prop);
            break;
    }
    thing = getAtom(thing);
    if (isComputedValue(thing))
        return log(thing.whyRun());
    else if (isReaction(thing))
        return log(thing.whyRun());
    return fail(getMessage("m025"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        break;
    case 2:
        thing = getAtom(thing, prop);
        break;
}
thing = getAtom(thing);
if (isComputedValue(thing))
    return log(thing.<span class="apidocCodeKeywordSpan">whyRun</span>());
else if (isReaction(thing))
    return log(thing.whyRun());
return fail(getMessage("m025"));
}
exports.whyRun = whyRun;
function createAction(actionName, fn) {
invariant(typeof fn === "function", getMessage("m026"));
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.Atom" id="apidoc.module.mobx.Atom">module mobx.Atom</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.Atom.Atom" id="apidoc.element.mobx.Atom.Atom">
        function <span class="apidocSignatureSpan">mobx.</span>Atom
        <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
    if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
    var _this = _super.call(this, name) || this;
    _this.name = name;
    _this.onBecomeObservedHandler = onBecomeObservedHandler;
    _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;
    _this.isPendingUnobservation = false;
    _this.isBeingTracked = false;
    return _this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.Atom.prototype" id="apidoc.module.mobx.Atom.prototype">module mobx.Atom.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.Atom.prototype.constructor" id="apidoc.element.mobx.Atom.prototype.constructor">
        function <span class="apidocSignatureSpan">mobx.Atom.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
    if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
    var _this = _super.call(this, name) || this;
    _this.name = name;
    _this.onBecomeObservedHandler = onBecomeObservedHandler;
    _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;
    _this.isPendingUnobservation = false;
    _this.isBeingTracked = false;
    return _this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Atom.prototype.onBecomeUnobserved" id="apidoc.element.mobx.Atom.prototype.onBecomeUnobserved">
        function <span class="apidocSignatureSpan">mobx.Atom.prototype.</span>onBecomeUnobserved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBecomeUnobserved = function () {
    this.isBeingTracked = false;
    this.onBecomeUnobservedHandler();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i &lt; list.length; i++) {
        var observable_1 = list[i];
        observable_1.isPendingUnobservation = false;
        if (observable_1.observers.length === 0) {
            observable_1.<span class="apidocCodeKeywordSpan">onBecomeUnobserved</span>();
        }
    }
    globalState.pendingUnobservations = [];
}
}
function reportObserved(observable) {
var derivation = globalState.trackingDerivation;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Atom.prototype.reportObserved" id="apidoc.element.mobx.Atom.prototype.reportObserved">
        function <span class="apidocSignatureSpan">mobx.Atom.prototype.</span>reportObserved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportObserved = function () {
    startBatch();
    _super.prototype.reportObserved.call(this);
    if (!this.isBeingTracked) {
        this.isBeingTracked = true;
        this.onBecomeObservedHandler();
    }
    endBatch();
    return !!globalState.trackingDerivation;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            removed: [],
            removedCount: 0
        });
    }
    return registerListener(this, listener);
};
ObservableArrayAdministration.prototype.getArrayLength = function () {
    this.atom.<span class="apidocCodeKeywordSpan">reportObserved</span>();
    return this.values.length;
};
ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {
    if (typeof newLength !== "number" || newLength &lt; 0)
        throw new Error("[mobx.array] Out of range: " + newLength);
    var currentLength = this.values.length;
    if (newLength === currentLength)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.BaseAtom" id="apidoc.module.mobx.BaseAtom">module mobx.BaseAtom</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.BaseAtom.BaseAtom" id="apidoc.element.mobx.BaseAtom.BaseAtom">
        function <span class="apidocSignatureSpan">mobx.</span>BaseAtom
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseAtom(name) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    this.name = name;
    this.isPendingUnobservation = true;
    this.observers = [];
    this.observersIndexes = {};
    this.diffValue = 0;
    this.lastAccessedBy = 0;
    this.lowestObserverState = IDerivationState.NOT_TRACKING;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.BaseAtom.prototype" id="apidoc.module.mobx.BaseAtom.prototype">module mobx.BaseAtom.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mobx.BaseAtom.prototype.onBecomeUnobserved" id="apidoc.element.mobx.BaseAtom.prototype.onBecomeUnobserved">
        function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>onBecomeUnobserved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBecomeUnobserved = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i &lt; list.length; i++) {
        var observable_1 = list[i];
        observable_1.isPendingUnobservation = false;
        if (observable_1.observers.length === 0) {
            observable_1.<span class="apidocCodeKeywordSpan">onBecomeUnobserved</span>();
        }
    }
    globalState.pendingUnobservations = [];
}
}
function reportObserved(observable) {
var derivation = globalState.trackingDerivation;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.BaseAtom.prototype.reportChanged" id="apidoc.element.mobx.BaseAtom.prototype.reportChanged">
        function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>reportChanged
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportChanged = function () {
    startBatch();
    propagateChanged(this);
    endBatch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var change = notify || notifySpy ? {
        object: this.array,
        type: "update",
        index: index, newValue: newValue, oldValue: oldValue
    } : null;
    if (notifySpy)
        spyReportStart(change);
    this.atom.<span class="apidocCodeKeywordSpan">reportChanged</span>();
    if (notify)
        notifyListeners(this, change);
    if (notifySpy)
        spyReportEnd();
};
ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {
    var notifySpy = !this.owned &amp;&amp; isSpyEnabled();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.BaseAtom.prototype.reportObserved" id="apidoc.element.mobx.BaseAtom.prototype.reportObserved">
        function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>reportObserved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportObserved = function () {
    reportObserved(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            removed: [],
            removedCount: 0
        });
    }
    return registerListener(this, listener);
};
ObservableArrayAdministration.prototype.getArrayLength = function () {
    this.atom.<span class="apidocCodeKeywordSpan">reportObserved</span>();
    return this.values.length;
};
ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {
    if (typeof newLength !== "number" || newLength &lt; 0)
        throw new Error("[mobx.array] Out of range: " + newLength);
    var currentLength = this.values.length;
    if (newLength === currentLength)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.BaseAtom.prototype.toString" id="apidoc.element.mobx.BaseAtom.prototype.toString">
        function <span class="apidocSignatureSpan">mobx.BaseAtom.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        prevValue = newValue;
    });
};
ComputedValue.prototype.toJSON = function () {
    return this.get();
};
ComputedValue.prototype.toString = function () {
    return this.name + "[" + this.derivation.<span class="apidocCodeKeywordSpan">toString</span>() + "]";
};
ComputedValue.prototype.valueOf = function () {
    return toPrimitive(this.get());
};
;
ComputedValue.prototype.whyRun = function () {
    var isTracking = Boolean(globalState.trackingDerivation);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.IObservableFactories" id="apidoc.module.mobx.IObservableFactories">module mobx.IObservableFactories</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.IObservableFactories" id="apidoc.element.mobx.IObservableFactories.IObservableFactories">
        function <span class="apidocSignatureSpan">mobx.</span>IObservableFactories
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IObservableFactories() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.IObservableFactories.prototype" id="apidoc.module.mobx.IObservableFactories.prototype">module mobx.IObservableFactories.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.array" id="apidoc.element.mobx.IObservableFactories.prototype.array">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>array
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">array = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("array");
    return new ObservableArray(initialValues, deepEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
See [#649](https://github.com/mobxjs/mobx/issues/649)

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.<span class="apidocCodeKeywordSpan">array</span>(initialValues, name?)`. Take a guess..
* `observable.map(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.box" id="apidoc.element.mobx.IObservableFactories.prototype.box">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>box
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (value, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("box");
    return new ObservableValue(value, deepEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.map(initialValues, name?)`
* `observable.<span class="apidocCodeKeywordSpan">box</span>(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx
/refguide/boxed.html) value, which can be read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.deep" id="apidoc.element.mobx.IObservableFactories.prototype.deep">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>deep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deep = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(deepEnhancer, arguments[0]);
    }
    else {
        return deepDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.map" id="apidoc.element.mobx.IObservableFactories.prototype.map">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>map
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("map");
    return new ObservableMap(initialValues, deepEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.<span class="apidocCodeKeywordSpan">map</span>(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.object" id="apidoc.element.mobx.IObservableFactories.prototype.object">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>object
        <span class="apidocSignatureSpan">(props, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">object = function (props, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("object");
    var res = {};
    asObservableObject(res, name);
    extendObservable(res, props);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

See [#649](https://github.com/mobxjs/mobx/issues/649)

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.<span class="apidocCodeKeywordSpan">object</span>(props, name?)` creates a new observable object, by cloning the give
 props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.map(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.ref" id="apidoc.element.mobx.IObservableFactories.prototype.ref">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>ref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ref = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(referenceEnhancer, arguments[0]);
    }
    else {
        return refDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0, l = listeners.length; i &lt; l; i++) {
        listeners[i](change);
    }
    untrackedEnd(prevU);
}
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.<span class="apidocCodeKeywordSpan">ref</span>(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.struct(value);
}
exports.asStructure = asStructure;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.shallow" id="apidoc.element.mobx.IObservableFactories.prototype.shallow">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallow = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(shallowEnhancer, arguments[0]);
    }
    else {
        return shallowDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Or as property modifier in combination with `observable.object` / `observable.extendObservable`.
Note that modifiers always 'stick' to the property. So they will remain in effect even if a new value is assigned.

```javascript
const taskStore = observable({
    tasks: observable.<span class="apidocCodeKeywordSpan">shallow</span>([])
})
```

See [modifiers](http://mobxjs.github.io/mobx/refguide/modifiers.html)

### `computed` api has been simplified
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.shallowArray" id="apidoc.element.mobx.IObservableFactories.prototype.shallowArray">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowArray
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowArray = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowArray");
    return new ObservableArray(initialValues, referenceEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.shallowObject(props, name?)`
* `observable.<span class="apidocCodeKeywordSpan">shallowArray</span>(initialValues, name?)`
* `observable.shallowMap(initialValues, name?)`
* `observable.shallowBox(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.shallowBox" id="apidoc.element.mobx.IObservableFactories.prototype.shallowBox">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowBox
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowBox = function (value, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowBox");
    return new ObservableValue(value, referenceEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.shallowObject(props, name?)`
* `observable.shallowArray(initialValues, name?)`
* `observable.shallowMap(initialValues, name?)`
* `observable.<span class="apidocCodeKeywordSpan">shallowBox</span>(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties

The `@observable` decorator can still be used to introduce observable properties. And like in MobX 2, it will automatically convert
 its values.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.shallowMap" id="apidoc.element.mobx.IObservableFactories.prototype.shallowMap">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowMap
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowMap = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowMap");
    return new ObservableMap(initialValues, referenceEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.shallowObject(props, name?)`
* `observable.shallowArray(initialValues, name?)`
* `observable.<span class="apidocCodeKeywordSpan">shallowMap</span>(initialValues, name?)`
* `observable.shallowBox(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties

The `@observable` decorator can still be used to introduce observable properties. And like in MobX 2, it will automatically convert
 its values.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.shallowObject" id="apidoc.element.mobx.IObservableFactories.prototype.shallowObject">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>shallowObject
        <span class="apidocSignatureSpan">(props, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowObject = function (props, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowObject");
    var res = {};
    asObservableObject(res, name);
    extendShallowObservable(res, props);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.<span class="apidocCodeKeywordSpan">shallowObject</span>(props, name?)`
* `observable.shallowArray(initialValues, name?)`
* `observable.shallowMap(initialValues, name?)`
* `observable.shallowBox(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.struct" id="apidoc.element.mobx.IObservableFactories.prototype.struct">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>struct
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">struct = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(deepStructEnhancer, arguments[0]);
    }
    else {
        return deepStructDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.<span class="apidocCodeKeywordSpan">struct</span>(value);
}
exports.asStructure = asStructure;
function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}
exports.asFlat = asFlat;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.IObservableFactories.prototype.deep" id="apidoc.module.mobx.IObservableFactories.prototype.deep">module mobx.IObservableFactories.prototype.deep</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.deep.deep" id="apidoc.element.mobx.IObservableFactories.prototype.deep.deep">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>deep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deep = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(deepEnhancer, arguments[0]);
    }
    else {
        return deepDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.deep.struct" id="apidoc.element.mobx.IObservableFactories.prototype.deep.struct">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.deep.</span>struct
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">struct = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(deepStructEnhancer, arguments[0]);
    }
    else {
        return deepStructDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.<span class="apidocCodeKeywordSpan">struct</span>(value);
}
exports.asStructure = asStructure;
function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}
exports.asFlat = asFlat;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.IObservableFactories.prototype.ref" id="apidoc.module.mobx.IObservableFactories.prototype.ref">module mobx.IObservableFactories.prototype.ref</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.ref.ref" id="apidoc.element.mobx.IObservableFactories.prototype.ref.ref">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.</span>ref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ref = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(referenceEnhancer, arguments[0]);
    }
    else {
        return refDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0, l = listeners.length; i &lt; l; i++) {
        listeners[i](change);
    }
    untrackedEnd(prevU);
}
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.<span class="apidocCodeKeywordSpan">ref</span>(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.struct(value);
}
exports.asStructure = asStructure;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.IObservableFactories.prototype.ref.struct" id="apidoc.element.mobx.IObservableFactories.prototype.ref.struct">
        function <span class="apidocSignatureSpan">mobx.IObservableFactories.prototype.ref.</span>struct
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">struct = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(refStructEnhancer, arguments[0]);
    }
    else {
        return refStructDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.<span class="apidocCodeKeywordSpan">struct</span>(value);
}
exports.asStructure = asStructure;
function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}
exports.asFlat = asFlat;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.ObservableMap" id="apidoc.module.mobx.ObservableMap">module mobx.ObservableMap</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.ObservableMap" id="apidoc.element.mobx.ObservableMap.ObservableMap">
        function <span class="apidocSignatureSpan">mobx.</span>ObservableMap
        <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableMap(initialData, enhancer, name) {
    if (enhancer === void 0) { enhancer = deepEnhancer; }
    if (name === void 0) { name = "ObservableMap@" + getNextId(); }
    this.enhancer = enhancer;
    this.name = name;
    this.$mobx = ObservableMapMarker;
    this._data = Object.create(null);
    this._hasMap = Object.create(null);
    this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true);
    this.interceptors = null;
    this.changeListeners = null;
    this.merge(initialData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.ObservableMap.prototype" id="apidoc.module.mobx.ObservableMap.prototype">module mobx.ObservableMap.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype._addValue" id="apidoc.element.mobx.ObservableMap.prototype._addValue">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_addValue
        <span class="apidocSignatureSpan">(name, newValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addValue = function (name, newValue) {
    var _this = this;
    runInTransaction(function () {
        var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + "." + name, false);
        newValue = observable.value;
        _this._updateHasMapEntry(name, true);
        _this._keys.push(name);
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
        type: "add",
        object: this,
        name: name, newValue: newValue
    } : null;
    if (notifySpy)
        spyReportStart(change);
    if (notify)
        notifyListeners(this, change);
    if (notifySpy)
        spyReportEnd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return this;
        value = change.newValue;
    }
    if (hasKey) {
        this._updateValue(key, value);
    }
    else {
        this.<span class="apidocCodeKeywordSpan">_addValue</span>(key, value);
    }
    return this;
};
ObservableMap.prototype.delete = function (key) {
    var _this = this;
    this.assertValidKey(key);
    key = "" + key;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype._has" id="apidoc.element.mobx.ObservableMap.prototype._has">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_has
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_has = function (key) {
    return typeof this._data[key] !== "undefined";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this._hasMap[key])
        return this._hasMap[key].get();
    return this._updateHasMapEntry(key, false).get();
};
ObservableMap.prototype.set = function (key, value) {
    this.assertValidKey(key);
    key = "" + key;
    var hasKey = this.<span class="apidocCodeKeywordSpan">_has</span>(key);
    if (hasInterceptors(this)) {
        var change = interceptChange(this, {
            type: hasKey ? "update" : "add",
            object: this,
            newValue: value,
            name: key
        });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype._updateHasMapEntry" id="apidoc.element.mobx.ObservableMap.prototype._updateHasMapEntry">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_updateHasMapEntry
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateHasMapEntry = function (key, value) {
    var entry = this._hasMap[key];
    if (entry) {
        entry.setNewValue(value);
    }
    else {
        entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + "." + key + "?", false);
    }
    return entry;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
ObservableMap.prototype.has = function (key) {
    if (!this.isValidKey(key))
        return false;
    key = "" + key;
    if (this._hasMap[key])
        return this._hasMap[key].get();
    return this.<span class="apidocCodeKeywordSpan">_updateHasMapEntry</span>(key, false).get();
};
ObservableMap.prototype.set = function (key, value) {
    this.assertValidKey(key);
    key = "" + key;
    var hasKey = this._has(key);
    if (hasInterceptors(this)) {
        var change = interceptChange(this, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype._updateValue" id="apidoc.element.mobx.ObservableMap.prototype._updateValue">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>_updateValue
        <span class="apidocSignatureSpan">(name, newValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateValue = function (name, newValue) {
    var observable = this._data[name];
    newValue = observable.prepareNewValue(newValue);
    if (newValue !== UNCHANGED) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
            type: "update",
            object: this,
            oldValue: observable.value,
            name: name, newValue: newValue
        } : null;
        if (notifySpy)
            spyReportStart(change);
        observable.setNewValue(newValue);
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            name: key
        });
        if (!change)
            return this;
        value = change.newValue;
    }
    if (hasKey) {
        this.<span class="apidocCodeKeywordSpan">_updateValue</span>(key, value);
    }
    else {
        this._addValue(key, value);
    }
    return this;
};
ObservableMap.prototype.delete = function (key) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.assertValidKey" id="apidoc.element.mobx.ObservableMap.prototype.assertValidKey">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>assertValidKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertValidKey = function (key) {
    if (!this.isValidKey(key))
        throw new Error("[mobx.map] Invalid key: '" + key + "', only strings, numbers and booleans are accepted as key in observable
 maps.");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return false;
    key = "" + key;
    if (this._hasMap[key])
        return this._hasMap[key].get();
    return this._updateHasMapEntry(key, false).get();
};
ObservableMap.prototype.set = function (key, value) {
    this.<span class="apidocCodeKeywordSpan">assertValidKey</span>(key);
    key = "" + key;
    var hasKey = this._has(key);
    if (hasInterceptors(this)) {
        var change = interceptChange(this, {
            type: hasKey ? "update" : "add",
            object: this,
            newValue: value,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.clear" id="apidoc.element.mobx.ObservableMap.prototype.clear">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
    var _this = this;
    runInTransaction(function () {
        untracked(function () {
            _this.keys().forEach(_this.delete, _this);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            _this.keys().forEach(_this.delete, _this);
        });
    });
};
ObservableMap.prototype.replace = function (values) {
    var _this = this;
    runInTransaction(function () {
        _this.<span class="apidocCodeKeywordSpan">clear</span>();
        _this.merge(values);
    });
    return this;
};
Object.defineProperty(ObservableMap.prototype, "size", {
    get: function () {
        return this._keys.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.delete" id="apidoc.element.mobx.ObservableMap.prototype.delete">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>delete
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (key) {
    var _this = this;
    this.assertValidKey(key);
    key = "" + key;
    if (hasInterceptors(this)) {
        var change = interceptChange(this, {
            type: "delete",
            object: this,
            name: key
        });
        if (!change)
            return false;
    }
    if (this._has(key)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
            type: "delete",
            object: this,
            oldValue: this._data[key].value,
            name: key
        } : null;
        if (notifySpy)
            spyReportStart(change);
        runInTransaction(function () {
            _this._keys.remove(key);
            _this._updateHasMapEntry(key, false);
            var observable = _this._data[key];
            observable.setNewValue(undefined);
            _this._data[key] = undefined;
        });
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
        return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.entries" id="apidoc.element.mobx.ObservableMap.prototype.entries">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>entries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entries = function () {
    var _this = this;
    return arrayAsIterator(this._keys.map(function (key) { return [key, _this.get(key)]; }));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ObservableMap.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    return ObservableMap;
}());
exports.ObservableMap = ObservableMap;
declareIterator(ObservableMap.prototype, function () {
    return this.<span class="apidocCodeKeywordSpan">entries</span>();
});
function map(initialValues) {
    deprecated("`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead");
    return observable.map(initialValues);
}
exports.map = map;
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.forEach" id="apidoc.element.mobx.ObservableMap.prototype.forEach">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, thisArg) {
    var _this = this;
    this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key, _this); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return extendObservableHelper(target, referenceEnhancer, properties);
}
exports.extendShallowObservable = extendShallowObservable;
function extendObservableHelper(target, defaultEnhancer, properties) {
invariant(arguments.length &gt;= 2, getMessage("m014"));
invariant(typeof target === "object", getMessage("m015"));
invariant(!(isObservableMap(target)), getMessage("m016"));
properties.<span class="apidocCodeKeywordSpan">forEach</span>(function (propSet) {
    invariant(typeof propSet === "object", getMessage("m017"));
    invariant(!isObservable(propSet), getMessage("m018"));
});
var adm = asObservableObject(target);
var definedProps = {};
for (var i = properties.length - 1; i &gt;= 0; i--) {
    var propSet = properties[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.get" id="apidoc.element.mobx.ObservableMap.prototype.get">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
    key = "" + key;
    if (this.has(key))
        return this._data[key].get();
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...





# 3.1.9

* Introduced explicit `.<span class="apidocCodeKeywordSpan">get</span>(index)` and `.set(index, value)` methods on observable arrays
, for issues that have trouble handling many property descriptors on objects. See also #574
* Made sure it is safe to call `onBecomeObserved` twice in row, fixes #874, #898
* Fixed typings of `IReactionDisposer`

# 3.1.8

* Fixed edge case where `autorun` was not triggered again if a computed value was invalidated by the reaction itself, see [#916](
https://github.com/mobxjs/mobx/issues/916), by @andykog
* Added support for primtive keys in `createTransformer`, See #920 by @dnakov
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.has" id="apidoc.element.mobx.ObservableMap.prototype.has">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>has
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (key) {
    if (!this.isValidKey(key))
        return false;
    key = "" + key;
    if (this._hasMap[key])
        return this._hasMap[key].get();
    return this._updateHasMapEntry(key, false).get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (notify)
        notifyListeners(this, change);
    if (notifySpy)
        spyReportEnd();
};
ObservableMap.prototype.get = function (key) {
    key = "" + key;
    if (this.<span class="apidocCodeKeywordSpan">has</span>(key))
        return this._data[key].get();
    return undefined;
};
ObservableMap.prototype.keys = function () {
    return arrayAsIterator(this._keys.slice());
};
ObservableMap.prototype.values = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.intercept" id="apidoc.element.mobx.ObservableMap.prototype.intercept">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>intercept
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intercept = function (handler) {
    return registerInterceptor(this, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof handler === "function")
    return interceptProperty(thing, propOrHandler, handler);
else
    return interceptInterceptable(thing, propOrHandler);
}
exports.intercept = intercept;
function interceptInterceptable(thing, handler) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">intercept</span>(handler);
}
function interceptProperty(thing, property, handler) {
return getAdministration(thing, property).intercept(handler);
}
function isComputed(value, property) {
if (value === null || value === undefined)
    return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.isValidKey" id="apidoc.element.mobx.ObservableMap.prototype.isValidKey">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>isValidKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidKey = function (key) {
    if (key === null || key === undefined)
        return false;
    if (typeof key === "string" || typeof key === "number" || typeof key === "boolean")
        return true;
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.changeListeners = null;
    this.merge(initialData);
}
ObservableMap.prototype._has = function (key) {
    return typeof this._data[key] !== "undefined";
};
ObservableMap.prototype.has = function (key) {
    if (!this.<span class="apidocCodeKeywordSpan">isValidKey</span>(key))
        return false;
    key = "" + key;
    if (this._hasMap[key])
        return this._hasMap[key].get();
    return this._updateHasMapEntry(key, false).get();
};
ObservableMap.prototype.set = function (key, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.keys" id="apidoc.element.mobx.ObservableMap.prototype.keys">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function () {
    return arrayAsIterator(this._keys.slice());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Fixed #377: `toJS` serialization of Dates and Regexes preserves the original values
* Fixed #379: `@action` decorated methods can now be inherited / overriden

# 2.3.3

* Fixed #186: Log a warning instead of an error if an exception is thrown in a derivation. Fixes issue where React Native would
produce unusable error screens (because it shows the first logged error)
* Fixed #333: Fixed some interoperability issues in combination with `Reflect` / `InversifyJS` decorators.  @andykog
* Fixed #333: `@observable` class properties are now _owned_ by their instance again, meaning they will show up in `Object.<span class="apidocCodeKeywordSpan">keys</span>()` and `.hasOwnProperty` @andykog

# 2.3.2

* Fixed #328: Fixed exception when inspecting observable in `onBecomeObserved`
* Fixed #341: `array.find` now returns `undefined` instead of `null` when nothing was found, behavior now matches the docs. (By @
hellectronic)

# 2.3.1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.merge" id="apidoc.element.mobx.ObservableMap.prototype.merge">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>merge
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (other) {
    var _this = this;
    if (isObservableMap(other)) {
        other = other.toJS();
    }
    runInTransaction(function () {
        if (isPlainObject(other))
            Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });
        else if (Array.isArray(other))
            other.forEach(function (_a) {
                var key = _a[0], value = _a[1];
                return _this.set(key, value);
            });
        else if (isES6Map(other))
            other.forEach(function (value, key) { return _this.set(key, value); });
        else if (other !== null &amp;&amp; other !== undefined)
            fail("Cannot initialize map from " + other);
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.name = name;
    this.$mobx = ObservableMapMarker;
    this._data = Object.create(null);
    this._hasMap = Object.create(null);
    this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true);
    this.interceptors = null;
    this.changeListeners = null;
    this.<span class="apidocCodeKeywordSpan">merge</span>(initialData);
}
ObservableMap.prototype._has = function (key) {
    return typeof this._data[key] !== "undefined";
};
ObservableMap.prototype.has = function (key) {
    if (!this.isValidKey(key))
        return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.observe" id="apidoc.element.mobx.ObservableMap.prototype.observe">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>observe
        <span class="apidocSignatureSpan">(listener, fireImmediately)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (listener, fireImmediately) {
    invariant(fireImmediately !== true, getMessage("m033"));
    return registerListener(this, listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof cbOrFire === "function")
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
else
    return observeObservable(thing, propOrCb, cbOrFire);
}
exports.observe = observe;
function observeObservable(thing, listener, fireImmediately) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">observe</span>(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
return getAdministration(thing, property).observe(listener, fireImmediately);
}
function toJS(source, detectCycles, __alreadySeen) {
if (detectCycles === void 0) { detectCycles = true; }
if (__alreadySeen === void 0) { __alreadySeen = []; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.replace" id="apidoc.element.mobx.ObservableMap.prototype.replace">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>replace
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (values) {
    var _this = this;
    runInTransaction(function () {
        _this.clear();
        _this.merge(values);
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Other changes

* **Breaking change:** The arguments to `observe` listeners for computed and boxed observables have changed and are now consistent
 with the other apis. Instead of invoking the callback with `(newValue: T, oldValue: T)` they are now invoked with a single change
 object: `(change: {newValue: T, oldValue: T, object, type: "update"})`
* Using transaction is now deprecated, use `action` or `runInAction` instead. Transactions now will enter an `untracked` block as
 well, just as actions, which removes the conceptual difference.
* Upgraded to typescript 2
* It is now possible to pass ES6 Maps to `observable` / observable maps. The map will be converted to an observable map (if keys
 are string like)
* Made `action` more debug friendly, it should now be easier to step through
* ObservableMap now has an additional method, `.<span class="apidocCodeKeywordSpan">replace</span>(data)`, which is a combination
 of `clear()` and `merge(data)`.
* Passing a function to `observable` will now create a boxed observable refering to that function
* Fixed #603: exceptions in transaction breaks future reactions
* Fixed #698: createTransformer should support default arguments
* Transactions are no longer reported grouped in spy events. If you want to group events, use actions instead.
* Normalized `spy` events further. Computed values and actions now report `object` instead of `target` for the scope they have been
 applied to.
* The following deprecated methods have been removed:
* `transaction`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.set" id="apidoc.element.mobx.ObservableMap.prototype.set">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>set
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value) {
    this.assertValidKey(key);
    key = "" + key;
    var hasKey = this._has(key);
    if (hasInterceptors(this)) {
        var change = interceptChange(this, {
            type: hasKey ? "update" : "add",
            object: this,
            newValue: value,
            name: key
        });
        if (!change)
            return this;
        value = change.newValue;
    }
    if (hasKey) {
        this._updateValue(key, value);
    }
    else {
        this._addValue(key, value);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...





# 3.1.9

* Introduced explicit `.get(index)` and `.<span class="apidocCodeKeywordSpan">set</span>(index, value)` methods on observable arrays
, for issues that have trouble handling many property descriptors on objects. See also #574
* Made sure it is safe to call `onBecomeObserved` twice in row, fixes #874, #898
* Fixed typings of `IReactionDisposer`

# 3.1.8

* Fixed edge case where `autorun` was not triggered again if a computed value was invalidated by the reaction itself, see [#916](
https://github.com/mobxjs/mobx/issues/916), by @andykog
* Added support for primtive keys in `createTransformer`, See #920 by @dnakov
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.toJS" id="apidoc.element.mobx.ObservableMap.prototype.toJS">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>toJS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJS = function () {
    var _this = this;
    var res = {};
    this.keys().forEach(function (key) { return res[key] = _this.get(key); });
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ObservableArray.prototype.replace = function (newItems) {
    return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
};
ObservableArray.prototype.toJS = function () {
    return this.slice();
};
ObservableArray.prototype.toJSON = function () {
    return this.<span class="apidocCodeKeywordSpan">toJS</span>();
};
ObservableArray.prototype.peek = function () {
    return this.$mobx.values;
};
ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
    if (fromIndex === void 0) { fromIndex = 0; }
    this.$mobx.atom.reportObserved();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.toJSON" id="apidoc.element.mobx.ObservableMap.prototype.toJSON">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    return this.toJS();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.toString" id="apidoc.element.mobx.ObservableMap.prototype.toString">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    var _this = this;
    return this.name + "[{ " + this.keys().map(function (key) { return key + ": " + ("" + _this.get(key)); }).join(", ") + " }]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        prevValue = newValue;
    });
};
ComputedValue.prototype.toJSON = function () {
    return this.get();
};
ComputedValue.prototype.toString = function () {
    return this.name + "[" + this.derivation.<span class="apidocCodeKeywordSpan">toString</span>() + "]";
};
ComputedValue.prototype.valueOf = function () {
    return toPrimitive(this.get());
};
;
ComputedValue.prototype.whyRun = function () {
    var isTracking = Boolean(globalState.trackingDerivation);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.ObservableMap.prototype.values" id="apidoc.element.mobx.ObservableMap.prototype.values">
        function <span class="apidocSignatureSpan">mobx.ObservableMap.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
    return arrayAsIterator(this._keys.map(this.get, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# 0.6.7:

* Improved logging

# 0.6.6:

* Deprecated observable array `.<span class="apidocCodeKeywordSpan">values</span>()` and `.clone()`
* Deprecated observeUntilInvalid; use sideEffect instead
* Renamed mobservable.toJson to mobservable.toJSON

# 0.6.5:

* It is no longer possible to create impure views; views that alter other reactive values.
* Update links to the new documentation.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.Reaction" id="apidoc.module.mobx.Reaction">module mobx.Reaction</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.Reaction.Reaction" id="apidoc.element.mobx.Reaction.Reaction">
        function <span class="apidocSignatureSpan">mobx.</span>Reaction
        <span class="apidocSignatureSpan">(name, onInvalidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reaction(name, onInvalidate) {
    if (name === void 0) { name = "Reaction@" + getNextId(); }
    this.name = name;
    this.onInvalidate = onInvalidate;
    this.observing = [];
    this.newObserving = [];
    this.dependenciesState = IDerivationState.NOT_TRACKING;
    this.diffValue = 0;
    this.runId = 0;
    this.unboundDepsCount = 0;
    this.__mapid = "#" + getNextId();
    this.isDisposed = false;
    this._isScheduled = false;
    this._isTrackPending = false;
    this._isRunning = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.Reaction.prototype" id="apidoc.module.mobx.Reaction.prototype">module mobx.Reaction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.dispose" id="apidoc.element.mobx.Reaction.prototype.dispose">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
    if (!this.isDisposed) {
        this.isDisposed = true;
        if (!this._isRunning) {
            startBatch();
            clearObserving(this);
            endBatch();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        name = ("When@" + getNextId());
        predicate = arg1;
        effect = arg2;
        scope = arg3;
    }
    var disposer = autorun(name, function (r) {
        if (predicate.call(scope)) {
            r.<span class="apidocCodeKeywordSpan">dispose</span>();
            var prevUntracked = untrackedStart();
            effect.call(scope);
            untrackedEnd(prevUntracked);
        }
    });
    return disposer;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.getDisposer" id="apidoc.element.mobx.Reaction.prototype.getDisposer">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>getDisposer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDisposer = function () {
    var r = this.dispose.bind(this);
    r.$mobx = this;
    r.onError = registerErrorHandler;
    return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var reaction = new Reaction(name, function () {
    this.track(reactionRunner);
});
function reactionRunner() {
    view(reaction);
}
reaction.schedule();
return reaction.<span class="apidocCodeKeywordSpan">getDisposer</span>();
}
exports.autorun = autorun;
function when(arg1, arg2, arg3, arg4) {
var name, predicate, effect, scope;
if (typeof arg1 === "string") {
    name = arg1;
    predicate = arg2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.isScheduled" id="apidoc.element.mobx.Reaction.prototype.isScheduled">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>isScheduled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isScheduled = function () {
    return this._isScheduled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return r;
};
Reaction.prototype.toString = function () {
    return "Reaction[" + this.name + "]";
};
Reaction.prototype.whyRun = function () {
    var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) { return dep.name; });
    return ("\nWhyRun? reaction '" + this.name + "':\n * Status: [" + (this.isDisposed ? "stopped
" : this._isRunning ? "running" : this.<span class="apidocCodeKeywordSpan">isScheduled</span>() ? "scheduled
" : "idle") + "]\n * This reaction will re-run if any of the following observables changes:\n    " + joinStrings(observing) + "\n    " + ((this._isRunning) ? " (... or any observable accessed during the remainder of the current run)" : "") + "\n\t" + getMessage("m038") + "\n");
};
return Reaction;
}());
exports.Reaction = Reaction;
function registerErrorHandler(handler) {
invariant(this &amp;&amp; this.$mobx &amp;&amp; isReaction(this.$mobx), "Invalid `this`");
invariant(!this.$mobx.errorHandler, "Only one onErrorHandler can be registered");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.onBecomeStale" id="apidoc.element.mobx.Reaction.prototype.onBecomeStale">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>onBecomeStale
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onBecomeStale = function () {
    this.schedule();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (dep.diffValue === 1) {
        dep.diffValue = 0;
        addObserver(dep, derivation);
    }
}
if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) {
    derivation.dependenciesState = lowestNewObservingDerivationState;
    derivation.<span class="apidocCodeKeywordSpan">onBecomeStale</span>();
}
}
function clearObserving(derivation) {
var obs = derivation.observing;
derivation.observing = [];
var i = obs.length;
while (i--)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.reportExceptionInDerivation" id="apidoc.element.mobx.Reaction.prototype.reportExceptionInDerivation">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>reportExceptionInDerivation
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportExceptionInDerivation = function (error) {
    var _this = this;
    if (this.errorHandler) {
        this.errorHandler(error, this);
        return;
    }
    var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this;
    var messageToUser = getMessage("m037");
    console.error(message || messageToUser, error);
    if (isSpyEnabled()) {
        spyReport({
            type: "error",
            message: message,
            error: error,
            object: this
        });
    }
    globalState.globalReactionErrorHandlers.forEach(function (f) { return f(error, _this); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var result = trackDerivedFunction(this, fn, undefined);
    this._isRunning = false;
    this._isTrackPending = false;
    if (this.isDisposed) {
        clearObserving(this);
    }
    if (isCaughtException(result))
        this.<span class="apidocCodeKeywordSpan">reportExceptionInDerivation</span>(result.cause);
    if (notify) {
        spyReportEnd({
            time: Date.now() - startTime
        });
    }
    endBatch();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.runReaction" id="apidoc.element.mobx.Reaction.prototype.runReaction">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>runReaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runReaction = function () {
    if (!this.isDisposed) {
        startBatch();
        this._isScheduled = false;
        if (shouldCompute(this)) {
            this._isTrackPending = true;
            this.onInvalidate();
            if (this._isTrackPending &amp;&amp; isSpyEnabled()) {
                spyReport({
                    object: this,
                    type: "scheduled-reaction"
                });
            }
        }
        endBatch();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (++iterations === MAX_REACTION_ITERATIONS) {
        console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations
."
            + (" Probably there is a cycle in the reactive function: " + allReactions[0]));
        allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l = remainingReactions.length; i &lt; l; i++)
        remainingReactions[i].<span class="apidocCodeKeywordSpan">runReaction</span>();
}
globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
var baseScheduler = reactionScheduler;
reactionScheduler = function (f) { return fn(function () { return baseScheduler(f); }); };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.schedule" id="apidoc.element.mobx.Reaction.prototype.schedule">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>schedule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schedule = function () {
    if (!this._isScheduled) {
        this._isScheduled = true;
        globalState.pendingReactions.push(this);
        runReactions();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    view = view.bind(scope);
var reaction = new Reaction(name, function () {
    this.track(reactionRunner);
});
function reactionRunner() {
    view(reaction);
}
reaction.<span class="apidocCodeKeywordSpan">schedule</span>();
return reaction.getDisposer();
}
exports.autorun = autorun;
function when(arg1, arg2, arg3, arg4) {
var name, predicate, effect, scope;
if (typeof arg1 === "string") {
    name = arg1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.toString" id="apidoc.element.mobx.Reaction.prototype.toString">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return "Reaction[" + this.name + "]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        prevValue = newValue;
    });
};
ComputedValue.prototype.toJSON = function () {
    return this.get();
};
ComputedValue.prototype.toString = function () {
    return this.name + "[" + this.derivation.<span class="apidocCodeKeywordSpan">toString</span>() + "]";
};
ComputedValue.prototype.valueOf = function () {
    return toPrimitive(this.get());
};
;
ComputedValue.prototype.whyRun = function () {
    var isTracking = Boolean(globalState.trackingDerivation);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.track" id="apidoc.element.mobx.Reaction.prototype.track">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>track
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">track = function (fn) {
    startBatch();
    var notify = isSpyEnabled();
    var startTime;
    if (notify) {
        startTime = Date.now();
        spyReportStart({
            object: this,
            type: "reaction",
            fn: fn
        });
    }
    this._isRunning = true;
    var result = trackDerivedFunction(this, fn, undefined);
    this._isRunning = false;
    this._isTrackPending = false;
    if (this.isDisposed) {
        clearObserving(this);
    }
    if (isCaughtException(result))
        this.reportExceptionInDerivation(result.cause);
    if (notify) {
        spyReportEnd({
            time: Date.now() - startTime
        });
    }
    endBatch();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        scope = arg2;
    }
    invariant(typeof view === "function", getMessage("m004"));
    invariant(isAction(view) === false, getMessage("m005"));
    if (scope)
        view = view.bind(scope);
    var reaction = new Reaction(name, function () {
        this.<span class="apidocCodeKeywordSpan">track</span>(reactionRunner);
    });
    function reactionRunner() {
        view(reaction);
    }
    reaction.schedule();
    return reaction.getDisposer();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.Reaction.prototype.whyRun" id="apidoc.element.mobx.Reaction.prototype.whyRun">
        function <span class="apidocSignatureSpan">mobx.Reaction.prototype.</span>whyRun
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whyRun = function () {
    var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) { return dep.name; });
    return ("\nWhyRun? reaction '" + this.name + "':\n * Status: [" + (this.isDisposed ? "stopped" : this._isRunning ? "running" :
this.isScheduled() ? "scheduled" : "idle") + "]\n * This reaction will re-run if any of the following observables changes:\n    " + joinStrings(observing) + "\n    " + ((this._isRunning) ? " (... or any observable accessed during the remainder of the current run)" : "") + "\n\t" + getMessage("m038") + "\n");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        break;
    case 2:
        thing = getAtom(thing, prop);
        break;
}
thing = getAtom(thing);
if (isComputedValue(thing))
    return log(thing.<span class="apidocCodeKeywordSpan">whyRun</span>());
else if (isReaction(thing))
    return log(thing.whyRun());
return fail(getMessage("m025"));
}
exports.whyRun = whyRun;
function createAction(actionName, fn) {
invariant(typeof fn === "function", getMessage("m026"));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.action" id="apidoc.module.mobx.action">module mobx.action</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.action.action" id="apidoc.element.mobx.action.action">
        function <span class="apidocSignatureSpan">mobx.</span>action
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function action(arg1, arg2, arg3, arg4) {
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "function")
        return createAction(arg1.name || "&lt;unnamed action&gt;", arg1);
    if (arguments.length === 2 &amp;&amp; typeof arg2 === "function")
        return createAction(arg1, arg2);
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "string")
        return namedActionDecorator(arg1);
    return namedActionDecorator(arg2).apply(null, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.action.bound" id="apidoc.element.mobx.action.bound">
        function <span class="apidocSignatureSpan">mobx.action.</span>bound
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function boundAction(arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
        var action_1 = createAction("&lt;not yet bound action&gt;", arg1);
        action_1.autoBind = true;
        return action_1;
    }
    return boundActionDecorator.apply(null, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.computed" id="apidoc.module.mobx.computed">module mobx.computed</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.computed.computed" id="apidoc.element.mobx.computed.computed">
        function <span class="apidocSignatureSpan">mobx.</span>computed
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        return computedDecorator.apply(null, arguments);
    }
    invariant(typeof arg1 === "function", getMessage("m011"));
    invariant(arguments.length &lt; 3, getMessage("m012"));
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.setter = typeof arg2 === "function" ? arg2 : opts.setter;
    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || "", opts
.setter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.computed.struct" id="apidoc.element.mobx.computed.struct">
        function <span class="apidocSignatureSpan">mobx.computed.</span>struct
        <span class="apidocSignatureSpan">(target, key, descriptor, customArgs, argLen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {
    if (argLen === void 0) { argLen = 0; }
    invariant(allowCustomArguments || quacksLikeADecorator(arguments), "This function is a decorator, but it wasn't invoked like
 a decorator");
    if (!descriptor) {
        var newDescriptor = {
            enumerable: enumerable,
            configurable: true,
            get: function () {
                if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true)
                    typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);
                return get.call(this, key);
            },
            set: function (v) {
                if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {
                    typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);
                }
                else {
                    set.call(this, key, v);
                }
            }
        };
        if (arguments.length &lt; 3 || arguments.length === 5 &amp;&amp; argLen &lt; 3) {
            Object.defineProperty(target, key, newDescriptor);
        }
        return newDescriptor;
    }
    else {
        if (!hasOwnProperty(target, "__mobxLazyInitializers")) {
            addHiddenProp(target, "__mobxLazyInitializers", (target.__mobxLazyInitializers &amp;&amp; target.__mobxLazyInitializers.slice
()) || []);
        }
        var value_1 = descriptor.value, initializer_1 = descriptor.initializer;
        target.__mobxLazyInitializers.push(function (instance) {
            onInitialize(instance, key, (initializer_1 ? initializer_1.call(instance) : value_1), customArgs, descriptor);
        });
        return {
            enumerable: enumerable, configurable: true,
            get: function () {
                if (this.__mobxDidRunLazyInitializers !== true)
                    runLazyInitializers(this);
                return get.call(this, key);
            },
            set: function (v) {
                if (this.__mobxDidRunLazyInitializers !== true)
                    runLazyInitializers(this);
                set.call(this, key, v);
            }
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.<span class="apidocCodeKeywordSpan">struct</span>(value);
}
exports.asStructure = asStructure;
function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}
exports.asFlat = asFlat;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.default" id="apidoc.module.mobx.default">module mobx.default</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.default.Atom" id="apidoc.element.mobx.default.Atom">
        function <span class="apidocSignatureSpan">mobx.default.</span>Atom
        <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
    if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
    var _this = _super.call(this, name) || this;
    _this.name = name;
    _this.onBecomeObservedHandler = onBecomeObservedHandler;
    _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;
    _this.isPendingUnobservation = false;
    _this.isBeingTracked = false;
    return _this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.BaseAtom" id="apidoc.element.mobx.default.BaseAtom">
        function <span class="apidocSignatureSpan">mobx.default.</span>BaseAtom
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseAtom(name) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    this.name = name;
    this.isPendingUnobservation = true;
    this.observers = [];
    this.observersIndexes = {};
    this.diffValue = 0;
    this.lastAccessedBy = 0;
    this.lowestObserverState = IDerivationState.NOT_TRACKING;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.IObservableFactories" id="apidoc.element.mobx.default.IObservableFactories">
        function <span class="apidocSignatureSpan">mobx.default.</span>IObservableFactories
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IObservableFactories() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.ObservableMap" id="apidoc.element.mobx.default.ObservableMap">
        function <span class="apidocSignatureSpan">mobx.default.</span>ObservableMap
        <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableMap(initialData, enhancer, name) {
    if (enhancer === void 0) { enhancer = deepEnhancer; }
    if (name === void 0) { name = "ObservableMap@" + getNextId(); }
    this.enhancer = enhancer;
    this.name = name;
    this.$mobx = ObservableMapMarker;
    this._data = Object.create(null);
    this._hasMap = Object.create(null);
    this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true);
    this.interceptors = null;
    this.changeListeners = null;
    this.merge(initialData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.Reaction" id="apidoc.element.mobx.default.Reaction">
        function <span class="apidocSignatureSpan">mobx.default.</span>Reaction
        <span class="apidocSignatureSpan">(name, onInvalidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reaction(name, onInvalidate) {
    if (name === void 0) { name = "Reaction@" + getNextId(); }
    this.name = name;
    this.onInvalidate = onInvalidate;
    this.observing = [];
    this.newObserving = [];
    this.dependenciesState = IDerivationState.NOT_TRACKING;
    this.diffValue = 0;
    this.runId = 0;
    this.unboundDepsCount = 0;
    this.__mapid = "#" + getNextId();
    this.isDisposed = false;
    this._isScheduled = false;
    this._isTrackPending = false;
    this._isRunning = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.action" id="apidoc.element.mobx.default.action">
        function <span class="apidocSignatureSpan">mobx.default.</span>action
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function action(arg1, arg2, arg3, arg4) {
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "function")
        return createAction(arg1.name || "&lt;unnamed action&gt;", arg1);
    if (arguments.length === 2 &amp;&amp; typeof arg2 === "function")
        return createAction(arg1, arg2);
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "string")
        return namedActionDecorator(arg1);
    return namedActionDecorator(arg2).apply(null, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.asFlat" id="apidoc.element.mobx.default.asFlat">
        function <span class="apidocSignatureSpan">mobx.default.</span>asFlat
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.asMap" id="apidoc.element.mobx.default.asMap">
        function <span class="apidocSignatureSpan">mobx.default.</span>asMap
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asMap(data) {
    deprecated("asMap is deprecated, use observable.map or observable.shallowMap instead");
    return observable.map(data || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.asReference" id="apidoc.element.mobx.default.asReference">
        function <span class="apidocSignatureSpan">mobx.default.</span>asReference
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.asStructure" id="apidoc.element.mobx.default.asStructure">
        function <span class="apidocSignatureSpan">mobx.default.</span>asStructure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.struct(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.autorun" id="apidoc.element.mobx.default.autorun">
        function <span class="apidocSignatureSpan">mobx.default.</span>autorun
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autorun(arg1, arg2, arg3) {
    var name, view, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        view = arg2;
        scope = arg3;
    }
    else {
        name = arg1.name || ("Autorun@" + getNextId());
        view = arg1;
        scope = arg2;
    }
    invariant(typeof view === "function", getMessage("m004"));
    invariant(isAction(view) === false, getMessage("m005"));
    if (scope)
        view = view.bind(scope);
    var reaction = new Reaction(name, function () {
        this.track(reactionRunner);
    });
    function reactionRunner() {
        view(reaction);
    }
    reaction.schedule();
    return reaction.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.autorunAsync" id="apidoc.element.mobx.default.autorunAsync">
        function <span class="apidocSignatureSpan">mobx.default.</span>autorunAsync
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autorunAsync(arg1, arg2, arg3, arg4) {
    var name, func, delay, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        func = arg2;
        delay = arg3;
        scope = arg4;
    }
    else {
        name = arg1.name || ("AutorunAsync@" + getNextId());
        func = arg1;
        delay = arg2;
        scope = arg3;
    }
    invariant(isAction(func) === false, getMessage("m006"));
    if (delay === void 0)
        delay = 1;
    if (scope)
        func = func.bind(scope);
    var isScheduled = false;
    var r = new Reaction(name, function () {
        if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                if (!r.isDisposed)
                    r.track(reactionRunner);
            }, delay);
        }
    });
    function reactionRunner() { func(r); }
    r.schedule();
    return r.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `toJSON` now serializes object trees with cycles as well. If you know the object tree is acyclic, pass in `false` as second parameter
 for a performance gain.

# 1.1.0

* Exposed `ObservableMap` type
* Introduced `mobservable.untracked(block)`
* Introduced `mobservable.<span class="apidocCodeKeywordSpan">autorunAsync</span>(block, delay)`

# 1.0.9

Removed accidental log message

# 1.0.7 / 1.0.8
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.computed" id="apidoc.element.mobx.default.computed">
        function <span class="apidocSignatureSpan">mobx.default.</span>computed
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        return computedDecorator.apply(null, arguments);
    }
    invariant(typeof arg1 === "function", getMessage("m011"));
    invariant(arguments.length &lt; 3, getMessage("m012"));
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.setter = typeof arg2 === "function" ? arg2 : opts.setter;
    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || "", opts
.setter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.createTransformer" id="apidoc.element.mobx.default.createTransformer">
        function <span class="apidocSignatureSpan">mobx.default.</span>createTransformer
        <span class="apidocSignatureSpan">(transformer, onCleanup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTransformer(transformer, onCleanup) {
    invariant(typeof transformer === "function" &amp;&amp; transformer.length &lt; 2, "createTransformer expects a function that accepts one
 argument");
    var objectCache = {};
    var resetId = globalState.resetId;
    var Transformer = (function (_super) {
        __extends(Transformer, _super);
        function Transformer(sourceIdentifier, sourceObject) {
            var _this = _super.call(this, function () { return transformer(sourceObject); }, undefined, false, "Transformer-" +
transformer.name + "-" + sourceIdentifier, undefined) || this;
            _this.sourceIdentifier = sourceIdentifier;
            _this.sourceObject = sourceObject;
            return _this;
        }
        Transformer.prototype.onBecomeUnobserved = function () {
            var lastValue = this.value;
            _super.prototype.onBecomeUnobserved.call(this);
            delete objectCache[this.sourceIdentifier];
            if (onCleanup)
                onCleanup(lastValue, this.sourceObject);
        };
        return Transformer;
    }(ComputedValue));
    return function (object) {
        if (resetId !== globalState.resetId) {
            objectCache = {};
            resetId = globalState.resetId;
        }
        var identifier = getMemoizationId(object);
        var reactiveTransformer = objectCache[identifier];
        if (reactiveTransformer)
            return reactiveTransformer.get();
        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);
        return reactiveTransformer.get();
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.expr" id="apidoc.element.mobx.default.expr">
        function <span class="apidocSignatureSpan">mobx.default.</span>expr
        <span class="apidocSignatureSpan">(expr, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expr(expr, scope) {
    if (!isComputingDerivation())
        console.warn(getMessage("m013"));
    return computed(expr, { context: scope }).get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.extendObservable" id="apidoc.element.mobx.default.extendObservable">
        function <span class="apidocSignatureSpan">mobx.default.</span>extendObservable
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendObservable(target) {
    var properties = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, deepEnhancer, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.extendShallowObservable" id="apidoc.element.mobx.default.extendShallowObservable">
        function <span class="apidocSignatureSpan">mobx.default.</span>extendShallowObservable
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendShallowObservable(target) {
    var properties = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, referenceEnhancer, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.intercept" id="apidoc.element.mobx.default.intercept">
        function <span class="apidocSignatureSpan">mobx.default.</span>intercept
        <span class="apidocSignatureSpan">(thing, propOrHandler, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intercept(thing, propOrHandler, handler) {
    if (typeof handler === "function")
        return interceptProperty(thing, propOrHandler, handler);
    else
        return interceptInterceptable(thing, propOrHandler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof handler === "function")
    return interceptProperty(thing, propOrHandler, handler);
else
    return interceptInterceptable(thing, propOrHandler);
}
exports.intercept = intercept;
function interceptInterceptable(thing, handler) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">intercept</span>(handler);
}
function interceptProperty(thing, property, handler) {
return getAdministration(thing, property).intercept(handler);
}
function isComputed(value, property) {
if (value === null || value === undefined)
    return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isAction" id="apidoc.element.mobx.default.isAction">
        function <span class="apidocSignatureSpan">mobx.default.</span>isAction
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAction(thing) {
    return typeof thing === "function" &amp;&amp; thing.isMobxAction === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isArrayLike" id="apidoc.element.mobx.default.isArrayLike">
        function <span class="apidocSignatureSpan">mobx.default.</span>isArrayLike
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayLike(x) {
    return Array.isArray(x) || isObservableArray(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isBoxedObservable" id="apidoc.element.mobx.default.isBoxedObservable">
        function <span class="apidocSignatureSpan">mobx.default.</span>isBoxedObservable
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBoxedObservable = function (x) {
    return isObject(x) &amp;&amp; x[propName] === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isComputed" id="apidoc.element.mobx.default.isComputed">
        function <span class="apidocSignatureSpan">mobx.default.</span>isComputed
        <span class="apidocSignatureSpan">(value, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isComputed(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableObject(value) === false)
            return false;
        var atom = getAtom(value, property);
        return isComputedValue(atom);
    }
    return isComputedValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isModifierDescriptor" id="apidoc.element.mobx.default.isModifierDescriptor">
        function <span class="apidocSignatureSpan">mobx.default.</span>isModifierDescriptor
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModifierDescriptor(thing) {
    return typeof thing === "object" &amp;&amp; thing !== null &amp;&amp; thing.isMobxModifierDescriptor === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isObservable" id="apidoc.element.mobx.default.isObservable">
        function <span class="apidocSignatureSpan">mobx.default.</span>isObservable
        <span class="apidocSignatureSpan">(value, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservable(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableArray(value) || isObservableMap(value))
            throw new Error(getMessage("m019"));
        else if (isObservableObject(value)) {
            var o = value.$mobx;
            return o.values &amp;&amp; !!o.values[property];
        }
        return false;
    }
    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isObservableArray" id="apidoc.element.mobx.default.isObservableArray">
        function <span class="apidocSignatureSpan">mobx.default.</span>isObservableArray
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservableArray(thing) {
    return isObject(thing) &amp;&amp; isObservableArrayAdministration(thing.$mobx);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isObservableMap" id="apidoc.element.mobx.default.isObservableMap">
        function <span class="apidocSignatureSpan">mobx.default.</span>isObservableMap
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObservableMap = function (x) {
    return isObject(x) &amp;&amp; x[propName] === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isObservableObject" id="apidoc.element.mobx.default.isObservableObject">
        function <span class="apidocSignatureSpan">mobx.default.</span>isObservableObject
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservableObject(thing) {
    if (isObject(thing)) {
        runLazyInitializers(thing);
        return isObservableObjectAdministration(thing.$mobx);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.isStrictModeEnabled" id="apidoc.element.mobx.default.isStrictModeEnabled">
        function <span class="apidocSignatureSpan">mobx.default.</span>isStrictModeEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStrictModeEnabled() {
    return globalState.strictMode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.map" id="apidoc.element.mobx.default.map">
        function <span class="apidocSignatureSpan">mobx.default.</span>map
        <span class="apidocSignatureSpan">(initialValues)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(initialValues) {
    deprecated("`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead");
    return observable.map(initialValues);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.<span class="apidocCodeKeywordSpan">map</span>(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.observable" id="apidoc.element.mobx.default.observable">
        function <span class="apidocSignatureSpan">mobx.default.</span>observable
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createObservable(v) {
    if (v === void 0) { v = undefined; }
    if (typeof arguments[1] === "string")
        return deepDecorator.apply(null, arguments);
    invariant(arguments.length &lt;= 1, getMessage("m021"));
    invariant(!isModifierDescriptor(v), getMessage("m020"));
    if (isObservable(v))
        return v;
    var res = deepEnhancer(v, undefined, undefined);
    if (res !== v)
        return res;
    return observable.box(v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# 1.1.7

* Fixed #77: package consumers with --noImplicitAny should be able to build

# 1.1.6

* Introduced `mobservable.fastArray(array)`, in addition to `mobservable.<span class="apidocCodeKeywordSpan">observable</span>(array
)`. Which is much faster when adding items but doesn't support enumerability (`for (var idx in ar) ..` loops).
* Introduced `observableArray.peek()`, for fast access to the array values. Should be used read-only.

# 1.1.5

* Fixed 71: transactions should not influence running computations

# 1.1.4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.observe" id="apidoc.element.mobx.default.observe">
        function <span class="apidocSignatureSpan">mobx.default.</span>observe
        <span class="apidocSignatureSpan">(thing, propOrCb, cbOrFire, fireImmediately)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function observe(thing, propOrCb, cbOrFire, fireImmediately) {
    if (typeof cbOrFire === "function")
        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    else
        return observeObservable(thing, propOrCb, cbOrFire);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof cbOrFire === "function")
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
else
    return observeObservable(thing, propOrCb, cbOrFire);
}
exports.observe = observe;
function observeObservable(thing, listener, fireImmediately) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">observe</span>(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
return getAdministration(thing, property).observe(listener, fireImmediately);
}
function toJS(source, detectCycles, __alreadySeen) {
if (detectCycles === void 0) { detectCycles = true; }
if (__alreadySeen === void 0) { __alreadySeen = []; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.reaction" id="apidoc.element.mobx.default.reaction">
        function <span class="apidocSignatureSpan">mobx.default.</span>reaction
        <span class="apidocSignatureSpan">(expression, effect, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reaction(expression, effect, arg3) {
    if (arguments.length &gt; 3) {
        fail(getMessage("m007"));
    }
    if (isModifierDescriptor(expression)) {
        fail(getMessage("m008"));
    }
    var opts;
    if (typeof arg3 === "object") {
        opts = arg3;
    }
    else {
        opts = {};
    }
    opts.name = opts.name || expression.name || effect.name || ("Reaction@" + getNextId());
    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;
    opts.delay = opts.delay || 0;
    opts.compareStructural = opts.compareStructural || opts.struct || false;
    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);
    if (opts.context) {
        expression = expression.bind(opts.context);
    }
    var firstTime = true;
    var isScheduled = false;
    var nextValue;
    var r = new Reaction(opts.name, function () {
        if (firstTime || opts.delay &lt; 1) {
            reactionRunner();
        }
        else if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                reactionRunner();
            }, opts.delay);
        }
    });
    function reactionRunner() {
        if (r.isDisposed)
            return;
        var changed = false;
        r.track(function () {
            var v = expression(r);
            changed = valueDidChange(opts.compareStructural, nextValue, v);
            nextValue = v;
        });
        if (firstTime &amp;&amp; opts.fireImmediately)
            effect(nextValue, r);
        if (!firstTime &amp;&amp; changed === true)
            effect(nextValue, r);
        if (firstTime)
            firstTime = false;
    }
    r.schedule();
    return r.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.runInAction" id="apidoc.element.mobx.default.runInAction">
        function <span class="apidocSignatureSpan">mobx.default.</span>runInAction
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runInAction(arg1, arg2, arg3) {
    var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "&lt;unnamed action&gt;";
    var fn = typeof arg1 === "function" ? arg1 : arg2;
    var scope = typeof arg1 === "function" ? arg2 : arg3;
    invariant(typeof fn === "function", getMessage("m002"));
    invariant(fn.length === 0, getMessage("m003"));
    invariant(typeof actionName === "string" &amp;&amp; actionName.length &gt; 0, "actions should have valid names, got: '" + actionName + "'");
    return executeAction(actionName, fn, scope, undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.spy" id="apidoc.element.mobx.default.spy">
        function <span class="apidocSignatureSpan">mobx.default.</span>spy
        <span class="apidocSignatureSpan">(listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spy(listener) {
    globalState.spyListeners.push(listener);
    return once(function () {
        var idx = globalState.spyListeners.indexOf(listener);
        if (idx !== -1)
            globalState.spyListeners.splice(idx, 1);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.toJS" id="apidoc.element.mobx.default.toJS">
        function <span class="apidocSignatureSpan">mobx.default.</span>toJS
        <span class="apidocSignatureSpan">(source, detectCycles, __alreadySeen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJS(source, detectCycles, __alreadySeen) {
    if (detectCycles === void 0) { detectCycles = true; }
    if (__alreadySeen === void 0) { __alreadySeen = []; }
    function cache(value) {
        if (detectCycles)
            __alreadySeen.push([source, value]);
        return value;
    }
    if (isObservable(source)) {
        if (detectCycles &amp;&amp; __alreadySeen === null)
            __alreadySeen = [];
        if (detectCycles &amp;&amp; source !== null &amp;&amp; typeof source === "object") {
            for (var i = 0, l = __alreadySeen.length; i &lt; l; i++)
                if (__alreadySeen[i][0] === source)
                    return __alreadySeen[i][1];
        }
        if (isObservableArray(source)) {
            var res = cache([]);
            var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); });
            res.length = toAdd.length;
            for (var i = 0, l = toAdd.length; i &lt; l; i++)
                res[i] = toAdd[i];
            return res;
        }
        if (isObservableObject(source)) {
            var res = cache({});
            for (var key in source)
                res[key] = toJS(source[key], detectCycles, __alreadySeen);
            return res;
        }
        if (isObservableMap(source)) {
            var res_1 = cache({});
            source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); });
            return res_1;
        }
        if (isObservableValue(source))
            return toJS(source.get(), detectCycles, __alreadySeen);
    }
    return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ObservableArray.prototype.replace = function (newItems) {
    return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
};
ObservableArray.prototype.toJS = function () {
    return this.slice();
};
ObservableArray.prototype.toJSON = function () {
    return this.<span class="apidocCodeKeywordSpan">toJS</span>();
};
ObservableArray.prototype.peek = function () {
    return this.$mobx.values;
};
ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
    if (fromIndex === void 0) { fromIndex = 0; }
    this.$mobx.atom.reportObserved();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.transaction" id="apidoc.element.mobx.default.transaction">
        function <span class="apidocSignatureSpan">mobx.default.</span>transaction
        <span class="apidocSignatureSpan">(action, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transaction(action, thisArg) {
    if (thisArg === void 0) { thisArg = undefined; }
    deprecated(getMessage("m023"));
    return runInTransaction.apply(undefined, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.untracked" id="apidoc.element.mobx.default.untracked">
        function <span class="apidocSignatureSpan">mobx.default.</span>untracked
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function untracked(action) {
    var prev = untrackedStart();
    var res = action();
    untrackedEnd(prev);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
# 1.1.1

* `toJSON` now serializes object trees with cycles as well. If you know the object tree is acyclic, pass in `false` as second parameter
 for a performance gain.

# 1.1.0

* Exposed `ObservableMap` type
* Introduced `mobservable.<span class="apidocCodeKeywordSpan">untracked</span>(block)`
* Introduced `mobservable.autorunAsync(block, delay)`

# 1.0.9

Removed accidental log message

# 1.0.7 / 1.0.8
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.useStrict" id="apidoc.element.mobx.default.useStrict">
        function <span class="apidocSignatureSpan">mobx.default.</span>useStrict
        <span class="apidocSignatureSpan">(strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function useStrict(strict) {
    invariant(globalState.trackingDerivation === null, getMessage("m028"));
    globalState.strictMode = strict;
    globalState.allowStateChanges = !strict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.when" id="apidoc.element.mobx.default.when">
        function <span class="apidocSignatureSpan">mobx.default.</span>when
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function when(arg1, arg2, arg3, arg4) {
    var name, predicate, effect, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        predicate = arg2;
        effect = arg3;
        scope = arg4;
    }
    else {
        name = ("When@" + getNextId());
        predicate = arg1;
        effect = arg2;
        scope = arg3;
    }
    var disposer = autorun(name, function (r) {
        if (predicate.call(scope)) {
            r.dispose();
            var prevUntracked = untrackedStart();
            effect.call(scope);
            untrackedEnd(prevUntracked);
        }
    });
    return disposer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.default.whyRun" id="apidoc.element.mobx.default.whyRun">
        function <span class="apidocSignatureSpan">mobx.default.</span>whyRun
        <span class="apidocSignatureSpan">(thing, prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whyRun(thing, prop) {
    switch (arguments.length) {
        case 0:
            thing = globalState.trackingDerivation;
            if (!thing)
                return log(getMessage("m024"));
            break;
        case 2:
            thing = getAtom(thing, prop);
            break;
    }
    thing = getAtom(thing);
    if (isComputedValue(thing))
        return log(thing.whyRun());
    else if (isReaction(thing))
        return log(thing.whyRun());
    return fail(getMessage("m025"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        break;
    case 2:
        thing = getAtom(thing, prop);
        break;
}
thing = getAtom(thing);
if (isComputedValue(thing))
    return log(thing.<span class="apidocCodeKeywordSpan">whyRun</span>());
else if (isReaction(thing))
    return log(thing.whyRun());
return fail(getMessage("m025"));
}
exports.whyRun = whyRun;
function createAction(actionName, fn) {
invariant(typeof fn === "function", getMessage("m026"));
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.extras" id="apidoc.module.mobx.extras">module mobx.extras</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.extras.allowStateChanges" id="apidoc.element.mobx.extras.allowStateChanges">
        function <span class="apidocSignatureSpan">mobx.extras.</span>allowStateChanges
        <span class="apidocSignatureSpan">(allowStateChanges, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allowStateChanges(allowStateChanges, func) {
    var prev = allowStateChangesStart(allowStateChanges);
    var res;
    try {
        res = func();
    }
    finally {
        allowStateChangesEnd(prev);
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.deepEqual" id="apidoc.element.mobx.extras.deepEqual">
        function <span class="apidocSignatureSpan">mobx.extras.</span>deepEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepEqual(a, b) {
    if (a === null &amp;&amp; b === null)
        return true;
    if (a === undefined &amp;&amp; b === undefined)
        return true;
    if (typeof a !== "object")
        return a === b;
    var aIsArray = isArrayLike(a);
    var aIsMap = isMapLike(a);
    if (aIsArray !== isArrayLike(b)) {
        return false;
    }
    else if (aIsMap !== isMapLike(b)) {
        return false;
    }
    else if (aIsArray) {
        if (a.length !== b.length)
            return false;
        for (var i = a.length - 1; i &gt;= 0; i--)
            if (!deepEqual(a[i], b[i]))
                return false;
        return true;
    }
    else if (aIsMap) {
        if (a.size !== b.size)
            return false;
        var equals_1 = true;
        a.forEach(function (value, key) {
            equals_1 = equals_1 &amp;&amp; deepEqual(b.get(key), value);
        });
        return equals_1;
    }
    else if (typeof a === "object" &amp;&amp; typeof b === "object") {
        if (a === null || b === null)
            return false;
        if (isMapLike(a) &amp;&amp; isMapLike(b)) {
            if (a.size !== b.size)
                return false;
            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());
        }
        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length)
            return false;
        for (var prop in a) {
            if (!(prop in b))
                return false;
            if (!deepEqual(a[prop], b[prop]))
                return false;
        }
        return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.getAdministration" id="apidoc.element.mobx.extras.getAdministration">
        function <span class="apidocSignatureSpan">mobx.extras.</span>getAdministration
        <span class="apidocSignatureSpan">(thing, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAdministration(thing, property) {
    invariant(thing, "Expecting some object");
    if (property !== undefined)
        return getAdministration(getAtom(thing, property));
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
        return thing;
    if (isObservableMap(thing))
        return thing;
    runLazyInitializers(thing);
    if (thing.$mobx)
        return thing.$mobx;
    invariant(false, "Cannot obtain administration from " + thing);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.getAtom" id="apidoc.element.mobx.extras.getAtom">
        function <span class="apidocSignatureSpan">mobx.extras.</span>getAtom
        <span class="apidocSignatureSpan">(thing, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAtom(thing, property) {
    if (typeof thing === "object" &amp;&amp; thing !== null) {
        if (isObservableArray(thing)) {
            invariant(property === undefined, getMessage("m036"));
            return thing.$mobx.atom;
        }
        if (isObservableMap(thing)) {
            var anyThing = thing;
            if (property === undefined)
                return getAtom(anyThing._keys);
            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];
            invariant(!!observable_2, "the entry '" + property + "' does not exist in the observable map '" + getDebugName(thing
) + "'");
            return observable_2;
        }
        runLazyInitializers(thing);
        if (isObservableObject(thing)) {
            if (!property)
                return fail("please specify a property");
            var observable_3 = thing.$mobx.values[property];
            invariant(!!observable_3, "no observable property '" + property + "' found on the observable object '" + getDebugName
(thing) + "'");
            return observable_3;
        }
        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
            return thing;
        }
    }
    else if (typeof thing === "function") {
        if (isReaction(thing.$mobx)) {
            return thing.$mobx;
        }
    }
    return fail("Cannot obtain atom from " + thing);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.getDebugName" id="apidoc.element.mobx.extras.getDebugName">
        function <span class="apidocSignatureSpan">mobx.extras.</span>getDebugName
        <span class="apidocSignatureSpan">(thing, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDebugName(thing, property) {
    var named;
    if (property !== undefined)
        named = getAtom(thing, property);
    else if (isObservableObject(thing) || isObservableMap(thing))
        named = getAdministration(thing);
    else
        named = getAtom(thing);
    return named.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.getDependencyTree" id="apidoc.element.mobx.extras.getDependencyTree">
        function <span class="apidocSignatureSpan">mobx.extras.</span>getDependencyTree
        <span class="apidocSignatureSpan">(thing, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDependencyTree(thing, property) {
    return nodeToDependencyTree(getAtom(thing, property));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.getGlobalState" id="apidoc.element.mobx.extras.getGlobalState">
        function <span class="apidocSignatureSpan">mobx.extras.</span>getGlobalState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getGlobalState() {
    return globalState;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.getObserverTree" id="apidoc.element.mobx.extras.getObserverTree">
        function <span class="apidocSignatureSpan">mobx.extras.</span>getObserverTree
        <span class="apidocSignatureSpan">(thing, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getObserverTree(thing, property) {
    return nodeToObserverTree(getAtom(thing, property));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.isComputingDerivation" id="apidoc.element.mobx.extras.isComputingDerivation">
        function <span class="apidocSignatureSpan">mobx.extras.</span>isComputingDerivation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isComputingDerivation() {
    return globalState.trackingDerivation !== null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.isSpyEnabled" id="apidoc.element.mobx.extras.isSpyEnabled">
        function <span class="apidocSignatureSpan">mobx.extras.</span>isSpyEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSpyEnabled() {
    return !!globalState.spyListeners.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.onReactionError" id="apidoc.element.mobx.extras.onReactionError">
        function <span class="apidocSignatureSpan">mobx.extras.</span>onReactionError
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onReactionError(handler) {
    globalState.globalReactionErrorHandlers.push(handler);
    return function () {
        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
        if (idx &gt;= 0)
            globalState.globalReactionErrorHandlers.splice(idx, 1);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Error handling in MobX has been made more consistent. In MobX 2 there was a best-effort recovery attempt if a derivation throws,
but MobX 3 introduced
more consistent behavior:

* Computed values that throw, store the exception and throw it to the next consumer(s). They keep tracking their data, so they are
 able to recover from exceptions in next re-runs.
* Reactions (like `autorun`, `when`, `reaction`, `render()`  of `observer` components) will always catch their exceptions, and just
 log the error. They will keep tracking their data, so they are able to recover in next re-runs.
* The disposer of a reaction exposes an `onError(handler)` method, which makes it possible to attach custom error handling logic
 to an reaction (that overrides the default logging behavior).
* `extras.<span class="apidocCodeKeywordSpan">onReactionError</span>(handler)` can be used to register a global onError handler
for reactions (will fire after spy "error" event). This can be useful in tests etc.

See [#731](https://github.com/mobxjs/mobx/issues/731)

### Removed error handling, improved error recovery

MobX always printed a warning when an exception was thrown from a computed value, reaction or react component: `[mobx] An uncaught
 exception occurred while calculating....`.
This warning was often confusing for people because they either had the impression that this was a mobx exception, while it actually
 is just informing about an exception that happened in userland code.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.reserveArrayBuffer" id="apidoc.element.mobx.extras.reserveArrayBuffer">
        function <span class="apidocSignatureSpan">mobx.extras.</span>reserveArrayBuffer
        <span class="apidocSignatureSpan">(max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reserveArrayBuffer(max) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index &lt; max; index++)
        createArrayBufferItem(index);
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.resetGlobalState" id="apidoc.element.mobx.extras.resetGlobalState">
        function <span class="apidocSignatureSpan">mobx.extras.</span>resetGlobalState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resetGlobalState() {
    globalState.resetId++;
    var defaultGlobals = new MobXGlobals();
    for (var key in defaultGlobals)
        if (persistentKeys.indexOf(key) === -1)
            globalState[key] = defaultGlobals[key];
    globalState.allowStateChanges = !globalState.strictMode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.setReactionScheduler" id="apidoc.element.mobx.extras.setReactionScheduler">
        function <span class="apidocSignatureSpan">mobx.extras.</span>setReactionScheduler
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setReactionScheduler(fn) {
    var baseScheduler = reactionScheduler;
    reactionScheduler = function (f) { return fn(function () { return baseScheduler(f); }); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.shareGlobalState" id="apidoc.element.mobx.extras.shareGlobalState">
        function <span class="apidocSignatureSpan">mobx.extras.</span>shareGlobalState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shareGlobalState() {
    var global = getGlobal();
    var ownState = globalState;
    if (global.__mobservableTrackingStack || global.__mobservableViewStack)
        throw new Error("[mobx] An incompatible version of mobservable is already loaded.");
    if (global.__mobxGlobal &amp;&amp; global.__mobxGlobal.version !== ownState.version)
        throw new Error("[mobx] An incompatible version of mobx is already loaded.");
    if (global.__mobxGlobal)
        globalState = global.__mobxGlobal;
    else
        global.__mobxGlobal = ownState;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
even when both packages where shipped with their own (embedded) version of MobX (!).

Obviously this is a nasty default as it breaks package isolation and might actually start to throw errors unintentionally when MobX
 is loaded multiple times in the same runtime by completely unrelated packages.
So this sharing behavior is now by default turned off.
Sharing MobX should be achieved by means of proper bundling, de-duplication of packages or using peer dependencies / externals if
 needed.
This is similar to packages like React, which will also bail out if you try to load it multiple times.

If you still want to use the old behavior, this can be achieved by running `mobx.extras.<span class="apidocCodeKeywordSpan">shareGlobalState
</span>()` on _all_ packages that want to share state with each other.
Since this behavior is probably not used outside Mendix, it has been deprecated immediately, so if you rely on this feature, please
 report in #621, so that it can be undeprecated if there is no more elegant solution.

See [#621](https://github.com/mobxjs/mobx/issues/621)

### Other changes

* **Breaking change:** The arguments to `observe` listeners for computed and boxed observables have changed and are now consistent
 with the other apis. Instead of invoking the callback with `(newValue: T, oldValue: T)` they are now invoked with a single change
 object: `(change: {newValue: T, oldValue: T, object, type: "update"})`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.spyReport" id="apidoc.element.mobx.extras.spyReport">
        function <span class="apidocSignatureSpan">mobx.extras.</span>spyReport
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spyReport(event) {
    if (!globalState.spyListeners.length)
        return;
    var listeners = globalState.spyListeners;
    for (var i = 0, l = listeners.length; i &lt; l; i++)
        listeners[i](event);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.spyReportEnd" id="apidoc.element.mobx.extras.spyReportEnd">
        function <span class="apidocSignatureSpan">mobx.extras.</span>spyReportEnd
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spyReportEnd(change) {
    if (change)
        spyReport(objectAssign({}, change, END_EVENT));
    else
        spyReport(END_EVENT);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.extras.spyReportStart" id="apidoc.element.mobx.extras.spyReportStart">
        function <span class="apidocSignatureSpan">mobx.extras.</span>spyReportStart
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spyReportStart(event) {
    var change = objectAssign({}, event, { spyReportStart: true });
    spyReport(change);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.mobx_umd" id="apidoc.module.mobx.mobx_umd">module mobx.mobx_umd</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.Atom" id="apidoc.element.mobx.mobx_umd.Atom">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>Atom
        <span class="apidocSignatureSpan">(name, onBecomeObservedHandler, onBecomeUnobservedHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
    if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
    var _this = _super.call(this, name) || this;
    _this.name = name;
    _this.onBecomeObservedHandler = onBecomeObservedHandler;
    _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;
    _this.isPendingUnobservation = false;
    _this.isBeingTracked = false;
    return _this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.BaseAtom" id="apidoc.element.mobx.mobx_umd.BaseAtom">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>BaseAtom
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BaseAtom(name) {
    if (name === void 0) { name = "Atom@" + getNextId(); }
    this.name = name;
    this.isPendingUnobservation = true;
    this.observers = [];
    this.observersIndexes = {};
    this.diffValue = 0;
    this.lastAccessedBy = 0;
    this.lowestObserverState = IDerivationState.NOT_TRACKING;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.IObservableFactories" id="apidoc.element.mobx.mobx_umd.IObservableFactories">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>IObservableFactories
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IObservableFactories() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.ObservableMap" id="apidoc.element.mobx.mobx_umd.ObservableMap">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>ObservableMap
        <span class="apidocSignatureSpan">(initialData, enhancer, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObservableMap(initialData, enhancer, name) {
    if (enhancer === void 0) { enhancer = deepEnhancer; }
    if (name === void 0) { name = "ObservableMap@" + getNextId(); }
    this.enhancer = enhancer;
    this.name = name;
    this.$mobx = ObservableMapMarker;
    this._data = Object.create(null);
    this._hasMap = Object.create(null);
    this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true);
    this.interceptors = null;
    this.changeListeners = null;
    this.merge(initialData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.Reaction" id="apidoc.element.mobx.mobx_umd.Reaction">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>Reaction
        <span class="apidocSignatureSpan">(name, onInvalidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reaction(name, onInvalidate) {
    if (name === void 0) { name = "Reaction@" + getNextId(); }
    this.name = name;
    this.onInvalidate = onInvalidate;
    this.observing = [];
    this.newObserving = [];
    this.dependenciesState = IDerivationState.NOT_TRACKING;
    this.diffValue = 0;
    this.runId = 0;
    this.unboundDepsCount = 0;
    this.__mapid = "#" + getNextId();
    this.isDisposed = false;
    this._isScheduled = false;
    this._isTrackPending = false;
    this._isRunning = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.action" id="apidoc.element.mobx.mobx_umd.action">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>action
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function action(arg1, arg2, arg3, arg4) {
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "function")
        return createAction(arg1.name || "&lt;unnamed action&gt;", arg1);
    if (arguments.length === 2 &amp;&amp; typeof arg2 === "function")
        return createAction(arg1, arg2);
    if (arguments.length === 1 &amp;&amp; typeof arg1 === "string")
        return namedActionDecorator(arg1);
    return namedActionDecorator(arg2).apply(null, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.asFlat" id="apidoc.element.mobx.mobx_umd.asFlat">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asFlat
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.asMap" id="apidoc.element.mobx.mobx_umd.asMap">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asMap
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asMap(data) {
    deprecated("asMap is deprecated, use observable.map or observable.shallowMap instead");
    return observable.map(data || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.asReference" id="apidoc.element.mobx.mobx_umd.asReference">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asReference
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.asStructure" id="apidoc.element.mobx.mobx_umd.asStructure">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>asStructure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.struct(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.autorun" id="apidoc.element.mobx.mobx_umd.autorun">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>autorun
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autorun(arg1, arg2, arg3) {
    var name, view, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        view = arg2;
        scope = arg3;
    }
    else {
        name = arg1.name || ("Autorun@" + getNextId());
        view = arg1;
        scope = arg2;
    }
    invariant(typeof view === "function", getMessage("m004"));
    invariant(isAction(view) === false, getMessage("m005"));
    if (scope)
        view = view.bind(scope);
    var reaction = new Reaction(name, function () {
        this.track(reactionRunner);
    });
    function reactionRunner() {
        view(reaction);
    }
    reaction.schedule();
    return reaction.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.autorunAsync" id="apidoc.element.mobx.mobx_umd.autorunAsync">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>autorunAsync
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autorunAsync(arg1, arg2, arg3, arg4) {
    var name, func, delay, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        func = arg2;
        delay = arg3;
        scope = arg4;
    }
    else {
        name = arg1.name || ("AutorunAsync@" + getNextId());
        func = arg1;
        delay = arg2;
        scope = arg3;
    }
    invariant(isAction(func) === false, getMessage("m006"));
    if (delay === void 0)
        delay = 1;
    if (scope)
        func = func.bind(scope);
    var isScheduled = false;
    var r = new Reaction(name, function () {
        if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                if (!r.isDisposed)
                    r.track(reactionRunner);
            }, delay);
        }
    });
    function reactionRunner() { func(r); }
    r.schedule();
    return r.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `toJSON` now serializes object trees with cycles as well. If you know the object tree is acyclic, pass in `false` as second parameter
 for a performance gain.

# 1.1.0

* Exposed `ObservableMap` type
* Introduced `mobservable.untracked(block)`
* Introduced `mobservable.<span class="apidocCodeKeywordSpan">autorunAsync</span>(block, delay)`

# 1.0.9

Removed accidental log message

# 1.0.7 / 1.0.8
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.computed" id="apidoc.element.mobx.mobx_umd.computed">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>computed
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        return computedDecorator.apply(null, arguments);
    }
    invariant(typeof arg1 === "function", getMessage("m011"));
    invariant(arguments.length &lt; 3, getMessage("m012"));
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.setter = typeof arg2 === "function" ? arg2 : opts.setter;
    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || "", opts
.setter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.createTransformer" id="apidoc.element.mobx.mobx_umd.createTransformer">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>createTransformer
        <span class="apidocSignatureSpan">(transformer, onCleanup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTransformer(transformer, onCleanup) {
    invariant(typeof transformer === "function" &amp;&amp; transformer.length &lt; 2, "createTransformer expects a function that accepts one
 argument");
    var objectCache = {};
    var resetId = globalState.resetId;
    var Transformer = (function (_super) {
        __extends(Transformer, _super);
        function Transformer(sourceIdentifier, sourceObject) {
            var _this = _super.call(this, function () { return transformer(sourceObject); }, undefined, false, "Transformer-" +
transformer.name + "-" + sourceIdentifier, undefined) || this;
            _this.sourceIdentifier = sourceIdentifier;
            _this.sourceObject = sourceObject;
            return _this;
        }
        Transformer.prototype.onBecomeUnobserved = function () {
            var lastValue = this.value;
            _super.prototype.onBecomeUnobserved.call(this);
            delete objectCache[this.sourceIdentifier];
            if (onCleanup)
                onCleanup(lastValue, this.sourceObject);
        };
        return Transformer;
    }(ComputedValue));
    return function (object) {
        if (resetId !== globalState.resetId) {
            objectCache = {};
            resetId = globalState.resetId;
        }
        var identifier = getMemoizationId(object);
        var reactiveTransformer = objectCache[identifier];
        if (reactiveTransformer)
            return reactiveTransformer.get();
        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);
        return reactiveTransformer.get();
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.expr" id="apidoc.element.mobx.mobx_umd.expr">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>expr
        <span class="apidocSignatureSpan">(expr, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expr(expr, scope) {
    if (!isComputingDerivation())
        console.warn(getMessage("m013"));
    return computed(expr, { context: scope }).get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.extendObservable" id="apidoc.element.mobx.mobx_umd.extendObservable">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>extendObservable
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendObservable(target) {
    var properties = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, deepEnhancer, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.extendShallowObservable" id="apidoc.element.mobx.mobx_umd.extendShallowObservable">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>extendShallowObservable
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendShallowObservable(target) {
    var properties = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, referenceEnhancer, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.intercept" id="apidoc.element.mobx.mobx_umd.intercept">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>intercept
        <span class="apidocSignatureSpan">(thing, propOrHandler, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intercept(thing, propOrHandler, handler) {
    if (typeof handler === "function")
        return interceptProperty(thing, propOrHandler, handler);
    else
        return interceptInterceptable(thing, propOrHandler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof handler === "function")
    return interceptProperty(thing, propOrHandler, handler);
else
    return interceptInterceptable(thing, propOrHandler);
}
exports.intercept = intercept;
function interceptInterceptable(thing, handler) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">intercept</span>(handler);
}
function interceptProperty(thing, property, handler) {
return getAdministration(thing, property).intercept(handler);
}
function isComputed(value, property) {
if (value === null || value === undefined)
    return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isAction" id="apidoc.element.mobx.mobx_umd.isAction">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isAction
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAction(thing) {
    return typeof thing === "function" &amp;&amp; thing.isMobxAction === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isArrayLike" id="apidoc.element.mobx.mobx_umd.isArrayLike">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isArrayLike
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayLike(x) {
    return Array.isArray(x) || isObservableArray(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isBoxedObservable" id="apidoc.element.mobx.mobx_umd.isBoxedObservable">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isBoxedObservable
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBoxedObservable = function (x) {
    return isObject(x) &amp;&amp; x[propName] === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isComputed" id="apidoc.element.mobx.mobx_umd.isComputed">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isComputed
        <span class="apidocSignatureSpan">(value, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isComputed(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableObject(value) === false)
            return false;
        var atom = getAtom(value, property);
        return isComputedValue(atom);
    }
    return isComputedValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isModifierDescriptor" id="apidoc.element.mobx.mobx_umd.isModifierDescriptor">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isModifierDescriptor
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isModifierDescriptor(thing) {
    return typeof thing === "object" &amp;&amp; thing !== null &amp;&amp; thing.isMobxModifierDescriptor === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isObservable" id="apidoc.element.mobx.mobx_umd.isObservable">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservable
        <span class="apidocSignatureSpan">(value, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservable(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableArray(value) || isObservableMap(value))
            throw new Error(getMessage("m019"));
        else if (isObservableObject(value)) {
            var o = value.$mobx;
            return o.values &amp;&amp; !!o.values[property];
        }
        return false;
    }
    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isObservableArray" id="apidoc.element.mobx.mobx_umd.isObservableArray">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservableArray
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservableArray(thing) {
    return isObject(thing) &amp;&amp; isObservableArrayAdministration(thing.$mobx);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isObservableMap" id="apidoc.element.mobx.mobx_umd.isObservableMap">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservableMap
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObservableMap = function (x) {
    return isObject(x) &amp;&amp; x[propName] === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isObservableObject" id="apidoc.element.mobx.mobx_umd.isObservableObject">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isObservableObject
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObservableObject(thing) {
    if (isObject(thing)) {
        runLazyInitializers(thing);
        return isObservableObjectAdministration(thing.$mobx);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.isStrictModeEnabled" id="apidoc.element.mobx.mobx_umd.isStrictModeEnabled">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>isStrictModeEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStrictModeEnabled() {
    return globalState.strictMode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.map" id="apidoc.element.mobx.mobx_umd.map">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>map
        <span class="apidocSignatureSpan">(initialValues)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(initialValues) {
    deprecated("`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead");
    return observable.map(initialValues);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.<span class="apidocCodeKeywordSpan">map</span>(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.observable" id="apidoc.element.mobx.mobx_umd.observable">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>observable
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createObservable(v) {
    if (v === void 0) { v = undefined; }
    if (typeof arguments[1] === "string")
        return deepDecorator.apply(null, arguments);
    invariant(arguments.length &lt;= 1, getMessage("m021"));
    invariant(!isModifierDescriptor(v), getMessage("m020"));
    if (isObservable(v))
        return v;
    var res = deepEnhancer(v, undefined, undefined);
    if (res !== v)
        return res;
    return observable.box(v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# 1.1.7

* Fixed #77: package consumers with --noImplicitAny should be able to build

# 1.1.6

* Introduced `mobservable.fastArray(array)`, in addition to `mobservable.<span class="apidocCodeKeywordSpan">observable</span>(array
)`. Which is much faster when adding items but doesn't support enumerability (`for (var idx in ar) ..` loops).
* Introduced `observableArray.peek()`, for fast access to the array values. Should be used read-only.

# 1.1.5

* Fixed 71: transactions should not influence running computations

# 1.1.4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.observe" id="apidoc.element.mobx.mobx_umd.observe">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>observe
        <span class="apidocSignatureSpan">(thing, propOrCb, cbOrFire, fireImmediately)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function observe(thing, propOrCb, cbOrFire, fireImmediately) {
    if (typeof cbOrFire === "function")
        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    else
        return observeObservable(thing, propOrCb, cbOrFire);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof cbOrFire === "function")
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
else
    return observeObservable(thing, propOrCb, cbOrFire);
}
exports.observe = observe;
function observeObservable(thing, listener, fireImmediately) {
return getAdministration(thing).<span class="apidocCodeKeywordSpan">observe</span>(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
return getAdministration(thing, property).observe(listener, fireImmediately);
}
function toJS(source, detectCycles, __alreadySeen) {
if (detectCycles === void 0) { detectCycles = true; }
if (__alreadySeen === void 0) { __alreadySeen = []; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.reaction" id="apidoc.element.mobx.mobx_umd.reaction">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>reaction
        <span class="apidocSignatureSpan">(expression, effect, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reaction(expression, effect, arg3) {
    if (arguments.length &gt; 3) {
        fail(getMessage("m007"));
    }
    if (isModifierDescriptor(expression)) {
        fail(getMessage("m008"));
    }
    var opts;
    if (typeof arg3 === "object") {
        opts = arg3;
    }
    else {
        opts = {};
    }
    opts.name = opts.name || expression.name || effect.name || ("Reaction@" + getNextId());
    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;
    opts.delay = opts.delay || 0;
    opts.compareStructural = opts.compareStructural || opts.struct || false;
    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);
    if (opts.context) {
        expression = expression.bind(opts.context);
    }
    var firstTime = true;
    var isScheduled = false;
    var nextValue;
    var r = new Reaction(opts.name, function () {
        if (firstTime || opts.delay &lt; 1) {
            reactionRunner();
        }
        else if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                reactionRunner();
            }, opts.delay);
        }
    });
    function reactionRunner() {
        if (r.isDisposed)
            return;
        var changed = false;
        r.track(function () {
            var v = expression(r);
            changed = valueDidChange(opts.compareStructural, nextValue, v);
            nextValue = v;
        });
        if (firstTime &amp;&amp; opts.fireImmediately)
            effect(nextValue, r);
        if (!firstTime &amp;&amp; changed === true)
            effect(nextValue, r);
        if (firstTime)
            firstTime = false;
    }
    r.schedule();
    return r.getDisposer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.runInAction" id="apidoc.element.mobx.mobx_umd.runInAction">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>runInAction
        <span class="apidocSignatureSpan">(arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runInAction(arg1, arg2, arg3) {
    var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "&lt;unnamed action&gt;";
    var fn = typeof arg1 === "function" ? arg1 : arg2;
    var scope = typeof arg1 === "function" ? arg2 : arg3;
    invariant(typeof fn === "function", getMessage("m002"));
    invariant(fn.length === 0, getMessage("m003"));
    invariant(typeof actionName === "string" &amp;&amp; actionName.length &gt; 0, "actions should have valid names, got: '" + actionName + "'");
    return executeAction(actionName, fn, scope, undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.spy" id="apidoc.element.mobx.mobx_umd.spy">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>spy
        <span class="apidocSignatureSpan">(listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function spy(listener) {
    globalState.spyListeners.push(listener);
    return once(function () {
        var idx = globalState.spyListeners.indexOf(listener);
        if (idx !== -1)
            globalState.spyListeners.splice(idx, 1);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.toJS" id="apidoc.element.mobx.mobx_umd.toJS">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>toJS
        <span class="apidocSignatureSpan">(source, detectCycles, __alreadySeen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJS(source, detectCycles, __alreadySeen) {
    if (detectCycles === void 0) { detectCycles = true; }
    if (__alreadySeen === void 0) { __alreadySeen = []; }
    function cache(value) {
        if (detectCycles)
            __alreadySeen.push([source, value]);
        return value;
    }
    if (isObservable(source)) {
        if (detectCycles &amp;&amp; __alreadySeen === null)
            __alreadySeen = [];
        if (detectCycles &amp;&amp; source !== null &amp;&amp; typeof source === "object") {
            for (var i = 0, l = __alreadySeen.length; i &lt; l; i++)
                if (__alreadySeen[i][0] === source)
                    return __alreadySeen[i][1];
        }
        if (isObservableArray(source)) {
            var res = cache([]);
            var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); });
            res.length = toAdd.length;
            for (var i = 0, l = toAdd.length; i &lt; l; i++)
                res[i] = toAdd[i];
            return res;
        }
        if (isObservableObject(source)) {
            var res = cache({});
            for (var key in source)
                res[key] = toJS(source[key], detectCycles, __alreadySeen);
            return res;
        }
        if (isObservableMap(source)) {
            var res_1 = cache({});
            source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); });
            return res_1;
        }
        if (isObservableValue(source))
            return toJS(source.get(), detectCycles, __alreadySeen);
    }
    return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ObservableArray.prototype.replace = function (newItems) {
    return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
};
ObservableArray.prototype.toJS = function () {
    return this.slice();
};
ObservableArray.prototype.toJSON = function () {
    return this.<span class="apidocCodeKeywordSpan">toJS</span>();
};
ObservableArray.prototype.peek = function () {
    return this.$mobx.values;
};
ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
    if (fromIndex === void 0) { fromIndex = 0; }
    this.$mobx.atom.reportObserved();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.transaction" id="apidoc.element.mobx.mobx_umd.transaction">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>transaction
        <span class="apidocSignatureSpan">(action, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transaction(action, thisArg) {
    if (thisArg === void 0) { thisArg = undefined; }
    deprecated(getMessage("m023"));
    return runInTransaction.apply(undefined, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.untracked" id="apidoc.element.mobx.mobx_umd.untracked">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>untracked
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function untracked(action) {
    var prev = untrackedStart();
    var res = action();
    untrackedEnd(prev);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
# 1.1.1

* `toJSON` now serializes object trees with cycles as well. If you know the object tree is acyclic, pass in `false` as second parameter
 for a performance gain.

# 1.1.0

* Exposed `ObservableMap` type
* Introduced `mobservable.<span class="apidocCodeKeywordSpan">untracked</span>(block)`
* Introduced `mobservable.autorunAsync(block, delay)`

# 1.0.9

Removed accidental log message

# 1.0.7 / 1.0.8
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.useStrict" id="apidoc.element.mobx.mobx_umd.useStrict">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>useStrict
        <span class="apidocSignatureSpan">(strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function useStrict(strict) {
    invariant(globalState.trackingDerivation === null, getMessage("m028"));
    globalState.strictMode = strict;
    globalState.allowStateChanges = !strict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.when" id="apidoc.element.mobx.mobx_umd.when">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>when
        <span class="apidocSignatureSpan">(arg1, arg2, arg3, arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function when(arg1, arg2, arg3, arg4) {
    var name, predicate, effect, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        predicate = arg2;
        effect = arg3;
        scope = arg4;
    }
    else {
        name = ("When@" + getNextId());
        predicate = arg1;
        effect = arg2;
        scope = arg3;
    }
    var disposer = autorun(name, function (r) {
        if (predicate.call(scope)) {
            r.dispose();
            var prevUntracked = untrackedStart();
            effect.call(scope);
            untrackedEnd(prevUntracked);
        }
    });
    return disposer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.mobx_umd.whyRun" id="apidoc.element.mobx.mobx_umd.whyRun">
        function <span class="apidocSignatureSpan">mobx.mobx_umd.</span>whyRun
        <span class="apidocSignatureSpan">(thing, prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whyRun(thing, prop) {
    switch (arguments.length) {
        case 0:
            thing = globalState.trackingDerivation;
            if (!thing)
                return log(getMessage("m024"));
            break;
        case 2:
            thing = getAtom(thing, prop);
            break;
    }
    thing = getAtom(thing);
    if (isComputedValue(thing))
        return log(thing.whyRun());
    else if (isReaction(thing))
        return log(thing.whyRun());
    return fail(getMessage("m025"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        break;
    case 2:
        thing = getAtom(thing, prop);
        break;
}
thing = getAtom(thing);
if (isComputedValue(thing))
    return log(thing.<span class="apidocCodeKeywordSpan">whyRun</span>());
else if (isReaction(thing))
    return log(thing.whyRun());
return fail(getMessage("m025"));
}
exports.whyRun = whyRun;
function createAction(actionName, fn) {
invariant(typeof fn === "function", getMessage("m026"));
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mobx.observable" id="apidoc.module.mobx.observable">module mobx.observable</a></h1>


    <h2>
        <a href="#apidoc.element.mobx.observable.observable" id="apidoc.element.mobx.observable.observable">
        function <span class="apidocSignatureSpan">mobx.</span>observable
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createObservable(v) {
    if (v === void 0) { v = undefined; }
    if (typeof arguments[1] === "string")
        return deepDecorator.apply(null, arguments);
    invariant(arguments.length &lt;= 1, getMessage("m021"));
    invariant(!isModifierDescriptor(v), getMessage("m020"));
    if (isObservable(v))
        return v;
    var res = deepEnhancer(v, undefined, undefined);
    if (res !== v)
        return res;
    return observable.box(v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# 1.1.7

* Fixed #77: package consumers with --noImplicitAny should be able to build

# 1.1.6

* Introduced `mobservable.fastArray(array)`, in addition to `mobservable.<span class="apidocCodeKeywordSpan">observable</span>(array
)`. Which is much faster when adding items but doesn't support enumerability (`for (var idx in ar) ..` loops).
* Introduced `observableArray.peek()`, for fast access to the array values. Should be used read-only.

# 1.1.5

* Fixed 71: transactions should not influence running computations

# 1.1.4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.array" id="apidoc.element.mobx.observable.array">
        function <span class="apidocSignatureSpan">mobx.observable.</span>array
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">array = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("array");
    return new ObservableArray(initialValues, deepEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
See [#649](https://github.com/mobxjs/mobx/issues/649)

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.<span class="apidocCodeKeywordSpan">array</span>(initialValues, name?)`. Take a guess..
* `observable.map(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.box" id="apidoc.element.mobx.observable.box">
        function <span class="apidocSignatureSpan">mobx.observable.</span>box
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (value, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("box");
    return new ObservableValue(value, deepEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.map(initialValues, name?)`
* `observable.<span class="apidocCodeKeywordSpan">box</span>(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx
/refguide/boxed.html) value, which can be read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.deep" id="apidoc.element.mobx.observable.deep">
        function <span class="apidocSignatureSpan">mobx.observable.</span>deep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deep = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(deepEnhancer, arguments[0]);
    }
    else {
        return deepDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.map" id="apidoc.element.mobx.observable.map">
        function <span class="apidocSignatureSpan">mobx.observable.</span>map
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("map");
    return new ObservableMap(initialValues, deepEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.object(props, name?)` creates a new observable object, by cloning the give props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.<span class="apidocCodeKeywordSpan">map</span>(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.object" id="apidoc.element.mobx.observable.object">
        function <span class="apidocSignatureSpan">mobx.observable.</span>object
        <span class="apidocSignatureSpan">(props, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">object = function (props, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("object");
    var res = {};
    asObservableObject(res, name);
    extendObservable(res, props);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

See [#649](https://github.com/mobxjs/mobx/issues/649)

### Factories per observable type

There are now explicit methods to create an observable of a specific type.

* `observable.<span class="apidocCodeKeywordSpan">object</span>(props, name?)` creates a new observable object, by cloning the give
 props and making them observable
* `observable.array(initialValues, name?)`. Take a guess..
* `observable.map(initialValues, name?)`
* `observable.box(initialValue, name?)`. Creates a [boxed](http://mobxjs.github.io/mobx/refguide/boxed.html) value, which can be
 read from / written to using `.get()` and `.set(newValue)`
* `observable(value)`, as-is, based on the type of `value`, uses any of the above four functions to create a new observable.

### Shallow factories per type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.ref" id="apidoc.element.mobx.observable.ref">
        function <span class="apidocSignatureSpan">mobx.observable.</span>ref
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ref = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(referenceEnhancer, arguments[0]);
    }
    else {
        return refDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0, l = listeners.length; i &lt; l; i++) {
        listeners[i](change);
    }
    untrackedEnd(prevU);
}
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.<span class="apidocCodeKeywordSpan">ref</span>(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.struct(value);
}
exports.asStructure = asStructure;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.shallow" id="apidoc.element.mobx.observable.shallow">
        function <span class="apidocSignatureSpan">mobx.observable.</span>shallow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallow = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(shallowEnhancer, arguments[0]);
    }
    else {
        return shallowDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Or as property modifier in combination with `observable.object` / `observable.extendObservable`.
Note that modifiers always 'stick' to the property. So they will remain in effect even if a new value is assigned.

```javascript
const taskStore = observable({
    tasks: observable.<span class="apidocCodeKeywordSpan">shallow</span>([])
})
```

See [modifiers](http://mobxjs.github.io/mobx/refguide/modifiers.html)

### `computed` api has been simplified
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.shallowArray" id="apidoc.element.mobx.observable.shallowArray">
        function <span class="apidocSignatureSpan">mobx.observable.</span>shallowArray
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowArray = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowArray");
    return new ObservableArray(initialValues, referenceEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.shallowObject(props, name?)`
* `observable.<span class="apidocCodeKeywordSpan">shallowArray</span>(initialValues, name?)`
* `observable.shallowMap(initialValues, name?)`
* `observable.shallowBox(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.shallowBox" id="apidoc.element.mobx.observable.shallowBox">
        function <span class="apidocSignatureSpan">mobx.observable.</span>shallowBox
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowBox = function (value, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowBox");
    return new ObservableValue(value, referenceEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.shallowObject(props, name?)`
* `observable.shallowArray(initialValues, name?)`
* `observable.shallowMap(initialValues, name?)`
* `observable.<span class="apidocCodeKeywordSpan">shallowBox</span>(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties

The `@observable` decorator can still be used to introduce observable properties. And like in MobX 2, it will automatically convert
 its values.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.shallowMap" id="apidoc.element.mobx.observable.shallowMap">
        function <span class="apidocSignatureSpan">mobx.observable.</span>shallowMap
        <span class="apidocSignatureSpan">(initialValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowMap = function (initialValues, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowMap");
    return new ObservableMap(initialValues, referenceEnhancer, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.shallowObject(props, name?)`
* `observable.shallowArray(initialValues, name?)`
* `observable.<span class="apidocCodeKeywordSpan">shallowMap</span>(initialValues, name?)`
* `observable.shallowBox(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties

The `@observable` decorator can still be used to introduce observable properties. And like in MobX 2, it will automatically convert
 its values.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.shallowObject" id="apidoc.element.mobx.observable.shallowObject">
        function <span class="apidocSignatureSpan">mobx.observable.</span>shallowObject
        <span class="apidocSignatureSpan">(props, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowObject = function (props, name) {
    if (arguments.length &gt; 2)
        incorrectlyUsedAsDecorator("shallowObject");
    var res = {};
    asObservableObject(res, name);
    extendShallowObservable(res, props);
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The standard observable factories create observable structures that will try to turn any plain javascript value (arrays, objects
 or Maps) into observables.
Allthough this is fine in most cases, in some cases you might want to disable this autoconversion.
For example when storing objects from external libraries.
In MobX 2 you needed to use `asFlat` or `asReference` modifiers for this.
In MobX 3, there are factories to directly create non-converting data structures:

* `observable.<span class="apidocCodeKeywordSpan">shallowObject</span>(props, name?)`
* `observable.shallowArray(initialValues, name?)`
* `observable.shallowMap(initialValues, name?)`
* `observable.shallowBox(initialValue, name?)`

So for example, `observable.shallowArray([todo1, todo2])` will create an observable array, but it won't try to convert the
todos inside the array into observables as well.

### Shallow properties
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mobx.observable.struct" id="apidoc.element.mobx.observable.struct">
        function <span class="apidocSignatureSpan">mobx.observable.</span>struct
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">struct = function () {
    if (arguments.length &lt; 2) {
        return createModifierDescriptor(deepStructEnhancer, arguments[0]);
    }
    else {
        return deepStructDecorator.apply(null, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}
exports.asReference = asReference;
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.<span class="apidocCodeKeywordSpan">struct</span>(value);
}
exports.asStructure = asStructure;
function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}
exports.asFlat = asFlat;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>